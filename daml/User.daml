-- Copyright (c) 2021 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module User where
import Daml.Script
import DA.List

type Key = (Party, Text)
type Place = (Int, Int)

makeAdmin =
  script do
    admin <- allocateParty "Admin"
    submit admin do
      createCmd Admin with adminame = admin
    zoologist <- allocateParty "Zoologist"
    submit zoologist do
      createCmd Admin with adminame = zoologist
    meteorologist <- allocateParty "Meteorologist"
    submit meteorologist do
      createCmd Admin with adminame = meteorologist
    hamal <- allocateParty "Hamal"
    submit hamal do
      createCmd Admin with adminame = hamal
    

template Admin with
    adminame: Party
  where
    signatory adminame

    key adminame: Party
    maintainer key


template Contract
  with
    signatories: [Party]
  where
    signatory signatories
    ensure
      unique signatories


-- MAIN_TEMPLATE_BEGIN
template User with
    username: Party
    requests: [Request]
  where
    signatory username
-- MAIN_TEMPLATE_END

    key username: Party
    maintainer key

    -- REQUEST_BEGIN
    preconsuming choice SendRequest: ContractId User with
          receiver: Party
          receivers: [Party]
          contract: Contract
          content: Text
          geo: Place
        controller username
        do

          -- #TODO: make sure a new request won't be made if it exists with the exact same text

          create Request with sender = username, admin = receiver, contract = contract, receivers = receivers, signed = [], disapproved = [], content, status = "Sent", geo = geo
          (_, requestId) <- fetchByKey @Request (username, content) -- We divide it into two lines for the ID
          create this with requests = requestId :: requests
    -- REQUEST_END

template Request with
    sender: Party
    admin: Party
    contract: Contract
    receivers: [Party]
    signed: [Party]
    disapproved: [Party]
    content: Text
    status: Text
    geo: Place
  where
    signatory sender, signed

    key (sender, content) : Key
    maintainer key._1

    observer contract.signatories, admin

    let notSigned = filter (`notElem` signed) contract.signatories

    choice Sign : ContractId Request with
        signer : Party

      controller signer

        do
          assert (signer `elem` notSigned)
          create this with signed = signer :: signed

    choice Finalize : ContractId Contract with
        signer : Party

      controller signer

        do
          assert (sort signed == sort contract.signatories)
          create contract

    choice Disapprove : ContractId Request with
        signer : Party

      controller signer

        do
          assert (signer `elem` notSigned)
          create this with disapproved = signer :: disapproved

    choice Remove : () with
        signer : Party

      controller signer

        do
          archive self