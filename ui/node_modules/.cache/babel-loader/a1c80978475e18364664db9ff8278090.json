{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Map = exports.emptyMap = exports.TextMap = exports.Optional = exports.ContractId = exports.Date = exports.List = exports.Party = exports.Time = exports.Text = exports.Decimal = exports.Numeric = exports.Int = exports.Bool = exports.Unit = exports.lazyMemo = exports.memo = exports.lookupTemplate = exports.registerTemplate = void 0; // Copyright (c) 2021 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar jtv = __importStar(require(\"@mojotech/json-type-validation\"));\n\nvar lodash_1 = __importDefault(require(\"lodash\"));\n/**\n * @internal\n */\n\n\nvar registeredTemplates = {};\n/**\n * @internal\n */\n\nexports.registerTemplate = function (template) {\n  var templateId = template.templateId;\n  var oldTemplate = registeredTemplates[templateId];\n\n  if (oldTemplate === undefined) {\n    registeredTemplates[templateId] = template;\n    console.debug(\"Registered template \" + templateId + \".\");\n  } else {\n    console.warn(\"Trying to re-register template \" + templateId + \".\");\n  }\n};\n/**\n * @internal\n */\n\n\nexports.lookupTemplate = function (templateId) {\n  var template = registeredTemplates[templateId];\n\n  if (template === undefined) {\n    throw Error(\"Failed to look up template \" + templateId + \". Make sure your @daml/types version agrees with the used Daml SDK version.\");\n  }\n\n  return template;\n};\n/**\n * @internal Turn a thunk into a memoized version of itself. The memoized thunk\n * invokes the original thunk only on its first invocation and caches the result\n * for later uses. We use this to implement a version of `jtv.lazy` with\n * memoization.\n */\n\n\nfunction memo(thunk) {\n  var memoized = function () {\n    var cache = thunk();\n\n    memoized = function () {\n      return cache;\n    };\n\n    return cache;\n  }; // NOTE(MH): Since we change `memoized` when the resultung thunk is invoked\n  // for the first time, we need to return it \"by reference\". Thus, we return\n  // a closure which contains a reference to `memoized`.\n\n\n  return function () {\n    return memoized();\n  };\n}\n\nexports.memo = memo;\n/**\n * @internal Variation of `jtv.lazy` which memoizes the computed decoder on its\n * first invocation.\n */\n\nfunction lazyMemo(mkDecoder) {\n  return jtv.lazy(memo(mkDecoder));\n}\n\nexports.lazyMemo = lazyMemo;\n/**\n * Companion obect of the [[Unit]] type.\n */\n\nexports.Unit = {\n  decoder: jtv.object({}),\n  encode: function (t) {\n    return t;\n  }\n};\n/**\n * Companion object of the [[Bool]] type.\n */\n\nexports.Bool = {\n  decoder: jtv.boolean(),\n  encode: function (b) {\n    return b;\n  }\n};\n/**\n * Companion object of the [[Int]] type.\n */\n\nexports.Int = {\n  decoder: jtv.string(),\n  encode: function (i) {\n    return i;\n  }\n};\n/**\n * Companion function of the [[Numeric]] type.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nexports.Numeric = function (_) {\n  return {\n    decoder: jtv.string(),\n    encode: function (n) {\n      return n;\n    }\n  };\n};\n/**\n * Companion object of the [[Decimal]] type.\n */\n\n\nexports.Decimal = exports.Numeric(10);\n/**\n * Companion object of the [[Text]] type.\n */\n\nexports.Text = {\n  decoder: jtv.string(),\n  encode: function (t) {\n    return t;\n  }\n};\n/**\n * Companion object of the [[Time]] type.\n */\n\nexports.Time = {\n  decoder: jtv.string(),\n  encode: function (t) {\n    return t;\n  }\n};\n/**\n * Companion object of the [[Party]] type.\n */\n\nexports.Party = {\n  decoder: jtv.string(),\n  encode: function (p) {\n    return p;\n  }\n};\n/**\n * Companion object of the [[List]] type.\n */\n\nexports.List = function (t) {\n  return {\n    decoder: jtv.array(t.decoder),\n    encode: function (l) {\n      return l.map(function (element) {\n        return t.encode(element);\n      });\n    }\n  };\n};\n/**\n * Companion object of the [[Date]] type.\n */\n\n\nexports.Date = {\n  decoder: jtv.string(),\n  encode: function (d) {\n    return d;\n  }\n};\n/**\n * Used to `brand` [[ContractId]].\n */\n\nvar ContractIdBrand = Symbol();\n/**\n * Companion object of the [[ContractId]] type.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nexports.ContractId = function (_t) {\n  return {\n    decoder: jtv.string(),\n    encode: function (c) {\n      return c;\n    }\n  };\n};\n/**\n * This class does the actual work behind the [[Optional]] companion function.  In addition to\n * implementing the [[Serializable]] interface it also stores the [[Serializable]] instance of the\n * payload of the [[Optional]] and uses it to provide a decoder for the [[OptionalInner]] type.\n *\n * @typeparam T The type of the optionally present value.\n */\n\n\nvar OptionalWorker =\n/** @class */\nfunction () {\n  function OptionalWorker(payload) {\n    if (payload instanceof OptionalWorker) {\n      var payloadInnerDecoder = payload.innerDecoder;\n      this.innerDecoder = jtv.oneOf(jtv.constant([]), jtv.tuple([payloadInnerDecoder]));\n\n      this.encode = function (o) {\n        if (o === null) {\n          // Top-level enclosing Optional where the type argument is also\n          // Optional and we represent None.\n          return null;\n        } else {\n          // The current type is Optional<Optional<...>> and the current value\n          // is Some x. Therefore the nested value is represented as [] for\n          // x = None or as [y] for x = Some y. In both cases mapping the\n          // encoder of the type parameter does the right thing.\n          return o.map(function (nested) {\n            return payload.encode(nested);\n          });\n        }\n      };\n    } else {\n      // NOTE(MH): `T` is not of the form `Optional<U>` here and hence `null`\n      // does not extend `T`. Thus, `OptionalInner<T> = T`.\n      this.innerDecoder = payload.decoder;\n\n      this.encode = function (o) {\n        if (o === null) {\n          // This branch is only reached if we are at the top-level and the\n          // entire type is a non-nested Optional, i.e. Optional<U> where U is\n          // not Optional. Recursive calls from the other branch would stop\n          // before reaching this case, as nested None are empty lists and\n          // never null.\n          return null;\n        } else {\n          return payload.encode(o);\n        }\n      };\n    }\n\n    this.decoder = jtv.oneOf(jtv.constant(null), this.innerDecoder);\n  }\n\n  return OptionalWorker;\n}();\n/**\n * Companion function of the [[Optional]] type.\n */\n\n\nexports.Optional = function (t) {\n  return new OptionalWorker(t);\n};\n/**\n * Companion object of the [[TextMap]] type.\n */\n\n\nexports.TextMap = function (t) {\n  return {\n    decoder: jtv.dict(t.decoder),\n    encode: function (tm) {\n      var out = {};\n      Object.keys(tm).forEach(function (k) {\n        out[k] = t.encode(tm[k]);\n      });\n      return out;\n    }\n  };\n};\n\nfunction it(arr) {\n  var i;\n  return __generator(this, function (_a) {\n    switch (_a.label) {\n      case 0:\n        i = 0;\n        _a.label = 1;\n\n      case 1:\n        if (!(i < arr.length)) return [3\n        /*break*/\n        , 4];\n        return [4\n        /*yield*/\n        , lodash_1.default.cloneDeep(arr[i])];\n\n      case 2:\n        _a.sent();\n\n        _a.label = 3;\n\n      case 3:\n        i++;\n        return [3\n        /*break*/\n        , 1];\n\n      case 4:\n        return [2\n        /*return*/\n        , undefined];\n    }\n  });\n} // This code assumes that the decoder is only ever used in decoding values\n// straight from the API responses, and said raw responses are never reused\n// afterwards. This should be enforced by this class not being exported and the\n// daml-ledger module not letting raw JSON responses escape without going\n// through this.\n//\n// Without that assumption, the constructor would need to deep-copy its kvs\n// argument.\n\n\nvar MapImpl =\n/** @class */\nfunction () {\n  function MapImpl(kvs) {\n    // sorting done so that generic object deep comparison would find equal\n    // maps equal (as defined by jest's expect().toEqual())\n    this._kvs = lodash_1.default.sortBy(kvs, function (kv) {\n      return JSON.stringify(kv[0]);\n    });\n    this._keys = this._kvs.map(function (e) {\n      return e[0];\n    });\n    this._values = this._kvs.map(function (e) {\n      return e[1];\n    });\n  }\n\n  MapImpl.prototype._idx = function (k) {\n    return this._keys.findIndex(function (l) {\n      return lodash_1.default.isEqual(k, l);\n    });\n  };\n\n  MapImpl.prototype.has = function (k) {\n    return this._idx(k) !== -1;\n  };\n\n  MapImpl.prototype.get = function (k) {\n    return lodash_1.default.cloneDeep(this._values[this._idx(k)]);\n  };\n\n  MapImpl.prototype.set = function (k, v) {\n    if (this.has(k)) {\n      var cpy = this._kvs.slice();\n\n      cpy[this._idx(k)] = lodash_1.default.cloneDeep([k, v]);\n      return new MapImpl(cpy);\n    } else {\n      var head = lodash_1.default.cloneDeep([[k, v]]);\n      return new MapImpl(head.concat(this._kvs));\n    }\n  };\n\n  MapImpl.prototype.delete = function (k) {\n    var i = this._idx(k);\n\n    if (i !== -1) {\n      return new MapImpl(this._kvs.slice(0, i).concat(this._kvs.slice(i + 1)));\n    } else {\n      return this;\n    }\n  };\n\n  MapImpl.prototype.keys = function () {\n    return it(this._keys);\n  };\n\n  MapImpl.prototype.values = function () {\n    return it(this._values);\n  };\n\n  MapImpl.prototype.entries = function () {\n    return it(this._kvs);\n  };\n\n  MapImpl.prototype.entriesArray = function () {\n    return lodash_1.default.cloneDeep(this._kvs);\n  };\n\n  MapImpl.prototype.forEach = function (f, u) {\n    var g = u ? f.bind(u) : f;\n\n    for (var _i = 0, _a = this._kvs; _i < _a.length; _i++) {\n      var _b = _a[_i],\n          k = _b[0],\n          v = _b[1];\n      g(v, k, this);\n    }\n  };\n\n  return MapImpl;\n}();\n\nexports.emptyMap = function () {\n  return new MapImpl([]);\n};\n/**\n * Companion function of the [[GenMap]] type.\n */\n\n\nexports.Map = function (kd, vd) {\n  return {\n    decoder: jtv.array(jtv.tuple([kd.decoder, vd.decoder])).map(function (kvs) {\n      return new MapImpl(kvs);\n    }),\n    encode: function (m) {\n      return m.entriesArray();\n    }\n  };\n};","map":{"version":3,"sources":["../../../../../../language-support/ts/daml-types/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Map = exports.emptyMap = exports.TextMap = exports.Optional = exports.ContractId = exports.Date = exports.List = exports.Party = exports.Time = exports.Text = exports.Decimal = exports.Numeric = exports.Int = exports.Bool = exports.Unit = exports.lazyMemo = exports.memo = exports.lookupTemplate = exports.registerTemplate = void 0;\n// Copyright (c) 2021 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar jtv = __importStar(require(\"@mojotech/json-type-validation\"));\nvar lodash_1 = __importDefault(require(\"lodash\"));\n/**\n * @internal\n */\nvar registeredTemplates = {};\n/**\n * @internal\n */\nexports.registerTemplate = function (template) {\n    var templateId = template.templateId;\n    var oldTemplate = registeredTemplates[templateId];\n    if (oldTemplate === undefined) {\n        registeredTemplates[templateId] = template;\n        console.debug(\"Registered template \" + templateId + \".\");\n    }\n    else {\n        console.warn(\"Trying to re-register template \" + templateId + \".\");\n    }\n};\n/**\n * @internal\n */\nexports.lookupTemplate = function (templateId) {\n    var template = registeredTemplates[templateId];\n    if (template === undefined) {\n        throw Error(\"Failed to look up template \" + templateId + \". Make sure your @daml/types version agrees with the used Daml SDK version.\");\n    }\n    return template;\n};\n/**\n * @internal Turn a thunk into a memoized version of itself. The memoized thunk\n * invokes the original thunk only on its first invocation and caches the result\n * for later uses. We use this to implement a version of `jtv.lazy` with\n * memoization.\n */\nfunction memo(thunk) {\n    var memoized = function () {\n        var cache = thunk();\n        memoized = function () { return cache; };\n        return cache;\n    };\n    // NOTE(MH): Since we change `memoized` when the resultung thunk is invoked\n    // for the first time, we need to return it \"by reference\". Thus, we return\n    // a closure which contains a reference to `memoized`.\n    return function () { return memoized(); };\n}\nexports.memo = memo;\n/**\n * @internal Variation of `jtv.lazy` which memoizes the computed decoder on its\n * first invocation.\n */\nfunction lazyMemo(mkDecoder) {\n    return jtv.lazy(memo(mkDecoder));\n}\nexports.lazyMemo = lazyMemo;\n/**\n * Companion obect of the [[Unit]] type.\n */\nexports.Unit = {\n    decoder: jtv.object({}),\n    encode: function (t) { return t; },\n};\n/**\n * Companion object of the [[Bool]] type.\n */\nexports.Bool = {\n    decoder: jtv.boolean(),\n    encode: function (b) { return b; },\n};\n/**\n * Companion object of the [[Int]] type.\n */\nexports.Int = {\n    decoder: jtv.string(),\n    encode: function (i) { return i; },\n};\n/**\n * Companion function of the [[Numeric]] type.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexports.Numeric = function (_) {\n    return ({\n        decoder: jtv.string(),\n        encode: function (n) { return n; },\n    });\n};\n/**\n * Companion object of the [[Decimal]] type.\n */\nexports.Decimal = exports.Numeric(10);\n/**\n * Companion object of the [[Text]] type.\n */\nexports.Text = {\n    decoder: jtv.string(),\n    encode: function (t) { return t; },\n};\n/**\n * Companion object of the [[Time]] type.\n */\nexports.Time = {\n    decoder: jtv.string(),\n    encode: function (t) { return t; },\n};\n/**\n * Companion object of the [[Party]] type.\n */\nexports.Party = {\n    decoder: jtv.string(),\n    encode: function (p) { return p; },\n};\n/**\n * Companion object of the [[List]] type.\n */\nexports.List = function (t) { return ({\n    decoder: jtv.array(t.decoder),\n    encode: function (l) { return l.map(function (element) { return t.encode(element); }); },\n}); };\n/**\n * Companion object of the [[Date]] type.\n */\nexports.Date = {\n    decoder: jtv.string(),\n    encode: function (d) { return d; },\n};\n/**\n * Used to `brand` [[ContractId]].\n */\nvar ContractIdBrand = Symbol();\n/**\n * Companion object of the [[ContractId]] type.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexports.ContractId = function (_t) { return ({\n    decoder: jtv.string(),\n    encode: function (c) { return c; },\n}); };\n/**\n * This class does the actual work behind the [[Optional]] companion function.  In addition to\n * implementing the [[Serializable]] interface it also stores the [[Serializable]] instance of the\n * payload of the [[Optional]] and uses it to provide a decoder for the [[OptionalInner]] type.\n *\n * @typeparam T The type of the optionally present value.\n */\nvar OptionalWorker = /** @class */ (function () {\n    function OptionalWorker(payload) {\n        if (payload instanceof OptionalWorker) {\n            var payloadInnerDecoder = payload.innerDecoder;\n            this.innerDecoder = jtv.oneOf(jtv.constant([]), jtv.tuple([payloadInnerDecoder]));\n            this.encode = function (o) {\n                if (o === null) {\n                    // Top-level enclosing Optional where the type argument is also\n                    // Optional and we represent None.\n                    return null;\n                }\n                else {\n                    // The current type is Optional<Optional<...>> and the current value\n                    // is Some x. Therefore the nested value is represented as [] for\n                    // x = None or as [y] for x = Some y. In both cases mapping the\n                    // encoder of the type parameter does the right thing.\n                    return o.map(function (nested) { return payload.encode(nested); });\n                }\n            };\n        }\n        else {\n            // NOTE(MH): `T` is not of the form `Optional<U>` here and hence `null`\n            // does not extend `T`. Thus, `OptionalInner<T> = T`.\n            this.innerDecoder = payload.decoder;\n            this.encode = function (o) {\n                if (o === null) {\n                    // This branch is only reached if we are at the top-level and the\n                    // entire type is a non-nested Optional, i.e. Optional<U> where U is\n                    // not Optional. Recursive calls from the other branch would stop\n                    // before reaching this case, as nested None are empty lists and\n                    // never null.\n                    return null;\n                }\n                else {\n                    return payload.encode(o);\n                }\n            };\n        }\n        this.decoder = jtv.oneOf(jtv.constant(null), this.innerDecoder);\n    }\n    return OptionalWorker;\n}());\n/**\n * Companion function of the [[Optional]] type.\n */\nexports.Optional = function (t) {\n    return new OptionalWorker(t);\n};\n/**\n * Companion object of the [[TextMap]] type.\n */\nexports.TextMap = function (t) { return ({\n    decoder: jtv.dict(t.decoder),\n    encode: function (tm) {\n        var out = {};\n        Object.keys(tm).forEach(function (k) {\n            out[k] = t.encode(tm[k]);\n        });\n        return out;\n    }\n}); };\nfunction it(arr) {\n    var i;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                i = 0;\n                _a.label = 1;\n            case 1:\n                if (!(i < arr.length)) return [3 /*break*/, 4];\n                return [4 /*yield*/, lodash_1.default.cloneDeep(arr[i])];\n            case 2:\n                _a.sent();\n                _a.label = 3;\n            case 3:\n                i++;\n                return [3 /*break*/, 1];\n            case 4: return [2 /*return*/, undefined];\n        }\n    });\n}\n// This code assumes that the decoder is only ever used in decoding values\n// straight from the API responses, and said raw responses are never reused\n// afterwards. This should be enforced by this class not being exported and the\n// daml-ledger module not letting raw JSON responses escape without going\n// through this.\n//\n// Without that assumption, the constructor would need to deep-copy its kvs\n// argument.\nvar MapImpl = /** @class */ (function () {\n    function MapImpl(kvs) {\n        // sorting done so that generic object deep comparison would find equal\n        // maps equal (as defined by jest's expect().toEqual())\n        this._kvs = lodash_1.default.sortBy(kvs, function (kv) { return JSON.stringify(kv[0]); });\n        this._keys = this._kvs.map(function (e) { return e[0]; });\n        this._values = this._kvs.map(function (e) { return e[1]; });\n    }\n    MapImpl.prototype._idx = function (k) {\n        return this._keys.findIndex(function (l) { return lodash_1.default.isEqual(k, l); });\n    };\n    MapImpl.prototype.has = function (k) {\n        return this._idx(k) !== -1;\n    };\n    MapImpl.prototype.get = function (k) { return lodash_1.default.cloneDeep(this._values[this._idx(k)]); };\n    MapImpl.prototype.set = function (k, v) {\n        if (this.has(k)) {\n            var cpy = this._kvs.slice();\n            cpy[this._idx(k)] = lodash_1.default.cloneDeep([k, v]);\n            return new MapImpl(cpy);\n        }\n        else {\n            var head = lodash_1.default.cloneDeep([[k, v]]);\n            return new MapImpl(head.concat(this._kvs));\n        }\n    };\n    MapImpl.prototype.delete = function (k) {\n        var i = this._idx(k);\n        if (i !== -1) {\n            return new MapImpl(this._kvs.slice(0, i).concat(this._kvs.slice(i + 1)));\n        }\n        else {\n            return this;\n        }\n    };\n    MapImpl.prototype.keys = function () { return it(this._keys); };\n    MapImpl.prototype.values = function () { return it(this._values); };\n    MapImpl.prototype.entries = function () { return it(this._kvs); };\n    MapImpl.prototype.entriesArray = function () { return lodash_1.default.cloneDeep(this._kvs); };\n    MapImpl.prototype.forEach = function (f, u) {\n        var g = u ? f.bind(u) : f;\n        for (var _i = 0, _a = this._kvs; _i < _a.length; _i++) {\n            var _b = _a[_i], k = _b[0], v = _b[1];\n            g(v, k, this);\n        }\n    };\n    return MapImpl;\n}());\nexports.emptyMap = function () { return new MapImpl([]); };\n/**\n * Companion function of the [[GenMap]] type.\n */\nexports.Map = function (kd, vd) { return ({\n    decoder: jtv.array(jtv.tuple([kd.decoder, vd.decoder])).map(function (kvs) { return new MapImpl(kvs); }),\n    encode: function (m) { return m.entriesArray(); },\n}); };\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}