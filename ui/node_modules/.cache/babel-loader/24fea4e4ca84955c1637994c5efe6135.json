{"ast":null,"code":"/*\n * jwt-simple\n *\n * JSON Web Token encode and decode module for node.js\n *\n * Copyright(c) 2011 Kazuhito Hokamura\n * MIT Licensed\n */\n\n/**\n * module dependencies\n */\nvar crypto = require('crypto');\n/**\n * support algorithm mapping\n */\n\n\nvar algorithmMap = {\n  HS256: 'sha256',\n  HS384: 'sha384',\n  HS512: 'sha512',\n  RS256: 'RSA-SHA256'\n};\n/**\n * Map algorithm to hmac or sign type, to determine which crypto function to use\n */\n\nvar typeMap = {\n  HS256: 'hmac',\n  HS384: 'hmac',\n  HS512: 'hmac',\n  RS256: 'sign'\n};\n/**\n * expose object\n */\n\nvar jwt = module.exports;\n/**\n * version\n */\n\njwt.version = '0.5.6';\n/**\n * Decode jwt\n *\n * @param {Object} token\n * @param {String} key\n * @param {Boolean} [noVerify]\n * @param {String} [algorithm]\n * @return {Object} payload\n * @api public\n */\n\njwt.decode = function jwt_decode(token, key, noVerify, algorithm) {\n  // check token\n  if (!token) {\n    throw new Error('No token supplied');\n  } // check segments\n\n\n  var segments = token.split('.');\n\n  if (segments.length !== 3) {\n    throw new Error('Not enough or too many segments');\n  } // All segment should be base64\n\n\n  var headerSeg = segments[0];\n  var payloadSeg = segments[1];\n  var signatureSeg = segments[2]; // base64 decode and parse JSON\n\n  var header = JSON.parse(base64urlDecode(headerSeg));\n  var payload = JSON.parse(base64urlDecode(payloadSeg));\n\n  if (!noVerify) {\n    if (!algorithm && /BEGIN( RSA)? PUBLIC KEY/.test(key.toString())) {\n      algorithm = 'RS256';\n    }\n\n    var signingMethod = algorithmMap[algorithm || header.alg];\n    var signingType = typeMap[algorithm || header.alg];\n\n    if (!signingMethod || !signingType) {\n      throw new Error('Algorithm not supported');\n    } // verify signature. `sign` will return base64 string.\n\n\n    var signingInput = [headerSeg, payloadSeg].join('.');\n\n    if (!verify(signingInput, key, signingMethod, signingType, signatureSeg)) {\n      throw new Error('Signature verification failed');\n    } // Support for nbf and exp claims.\n    // According to the RFC, they should be in seconds.\n\n\n    if (payload.nbf && Date.now() < payload.nbf * 1000) {\n      throw new Error('Token not yet active');\n    }\n\n    if (payload.exp && Date.now() > payload.exp * 1000) {\n      throw new Error('Token expired');\n    }\n  }\n\n  return payload;\n};\n/**\n * Encode jwt\n *\n * @param {Object} payload\n * @param {String} key\n * @param {String} algorithm\n * @param {Object} options\n * @return {String} token\n * @api public\n */\n\n\njwt.encode = function jwt_encode(payload, key, algorithm, options) {\n  // Check key\n  if (!key) {\n    throw new Error('Require key');\n  } // Check algorithm, default is HS256\n\n\n  if (!algorithm) {\n    algorithm = 'HS256';\n  }\n\n  var signingMethod = algorithmMap[algorithm];\n  var signingType = typeMap[algorithm];\n\n  if (!signingMethod || !signingType) {\n    throw new Error('Algorithm not supported');\n  } // header, typ is fixed value.\n\n\n  var header = {\n    typ: 'JWT',\n    alg: algorithm\n  };\n\n  if (options && options.header) {\n    assignProperties(header, options.header);\n  } // create segments, all segments should be base64 string\n\n\n  var segments = [];\n  segments.push(base64urlEncode(JSON.stringify(header)));\n  segments.push(base64urlEncode(JSON.stringify(payload)));\n  segments.push(sign(segments.join('.'), key, signingMethod, signingType));\n  return segments.join('.');\n};\n/**\n * private util functions\n */\n\n\nfunction assignProperties(dest, source) {\n  for (var attr in source) {\n    if (source.hasOwnProperty(attr)) {\n      dest[attr] = source[attr];\n    }\n  }\n}\n\nfunction verify(input, key, method, type, signature) {\n  if (type === \"hmac\") {\n    return signature === sign(input, key, method, type);\n  } else if (type == \"sign\") {\n    return crypto.createVerify(method).update(input).verify(key, base64urlUnescape(signature), 'base64');\n  } else {\n    throw new Error('Algorithm type not recognized');\n  }\n}\n\nfunction sign(input, key, method, type) {\n  var base64str;\n\n  if (type === \"hmac\") {\n    base64str = crypto.createHmac(method, key).update(input).digest('base64');\n  } else if (type == \"sign\") {\n    base64str = crypto.createSign(method).update(input).sign(key, 'base64');\n  } else {\n    throw new Error('Algorithm type not recognized');\n  }\n\n  return base64urlEscape(base64str);\n}\n\nfunction base64urlDecode(str) {\n  return Buffer.from(base64urlUnescape(str), 'base64').toString();\n}\n\nfunction base64urlUnescape(str) {\n  str += new Array(5 - str.length % 4).join('=');\n  return str.replace(/\\-/g, '+').replace(/_/g, '/');\n}\n\nfunction base64urlEncode(str) {\n  return base64urlEscape(Buffer.from(str).toString('base64'));\n}\n\nfunction base64urlEscape(str) {\n  return str.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}","map":{"version":3,"sources":["/Users/liorkesos/projects/daml/create-daml-app/ui/node_modules/jwt-simple/lib/jwt.js"],"names":["crypto","require","algorithmMap","HS256","HS384","HS512","RS256","typeMap","jwt","module","exports","version","decode","jwt_decode","token","key","noVerify","algorithm","Error","segments","split","length","headerSeg","payloadSeg","signatureSeg","header","JSON","parse","base64urlDecode","payload","test","toString","signingMethod","alg","signingType","signingInput","join","verify","nbf","Date","now","exp","encode","jwt_encode","options","typ","assignProperties","push","base64urlEncode","stringify","sign","dest","source","attr","hasOwnProperty","input","method","type","signature","createVerify","update","base64urlUnescape","base64str","createHmac","digest","createSign","base64urlEscape","str","Buffer","from","Array","replace"],"mappings":"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","sourcesContent":["/*\n * jwt-simple\n *\n * JSON Web Token encode and decode module for node.js\n *\n * Copyright(c) 2011 Kazuhito Hokamura\n * MIT Licensed\n */\n\n/**\n * module dependencies\n */\nvar crypto = require('crypto');\n\n\n/**\n * support algorithm mapping\n */\nvar algorithmMap = {\n  HS256: 'sha256',\n  HS384: 'sha384',\n  HS512: 'sha512',\n  RS256: 'RSA-SHA256'\n};\n\n/**\n * Map algorithm to hmac or sign type, to determine which crypto function to use\n */\nvar typeMap = {\n  HS256: 'hmac',\n  HS384: 'hmac',\n  HS512: 'hmac',\n  RS256: 'sign'\n};\n\n\n/**\n * expose object\n */\nvar jwt = module.exports;\n\n\n/**\n * version\n */\njwt.version = '0.5.6';\n\n/**\n * Decode jwt\n *\n * @param {Object} token\n * @param {String} key\n * @param {Boolean} [noVerify]\n * @param {String} [algorithm]\n * @return {Object} payload\n * @api public\n */\njwt.decode = function jwt_decode(token, key, noVerify, algorithm) {\n  // check token\n  if (!token) {\n    throw new Error('No token supplied');\n  }\n  // check segments\n  var segments = token.split('.');\n  if (segments.length !== 3) {\n    throw new Error('Not enough or too many segments');\n  }\n\n  // All segment should be base64\n  var headerSeg = segments[0];\n  var payloadSeg = segments[1];\n  var signatureSeg = segments[2];\n\n  // base64 decode and parse JSON\n  var header = JSON.parse(base64urlDecode(headerSeg));\n  var payload = JSON.parse(base64urlDecode(payloadSeg));\n\n  if (!noVerify) {\n    if (!algorithm && /BEGIN( RSA)? PUBLIC KEY/.test(key.toString())) {\n      algorithm = 'RS256';\n    }\n\n    var signingMethod = algorithmMap[algorithm || header.alg];\n    var signingType = typeMap[algorithm || header.alg];\n    if (!signingMethod || !signingType) {\n      throw new Error('Algorithm not supported');\n    }\n\n    // verify signature. `sign` will return base64 string.\n    var signingInput = [headerSeg, payloadSeg].join('.');\n    if (!verify(signingInput, key, signingMethod, signingType, signatureSeg)) {\n      throw new Error('Signature verification failed');\n    }\n\n    // Support for nbf and exp claims.\n    // According to the RFC, they should be in seconds.\n    if (payload.nbf && Date.now() < payload.nbf*1000) {\n      throw new Error('Token not yet active');\n    }\n\n    if (payload.exp && Date.now() > payload.exp*1000) {\n      throw new Error('Token expired');\n    }\n  }\n\n  return payload;\n};\n\n\n/**\n * Encode jwt\n *\n * @param {Object} payload\n * @param {String} key\n * @param {String} algorithm\n * @param {Object} options\n * @return {String} token\n * @api public\n */\njwt.encode = function jwt_encode(payload, key, algorithm, options) {\n  // Check key\n  if (!key) {\n    throw new Error('Require key');\n  }\n\n  // Check algorithm, default is HS256\n  if (!algorithm) {\n    algorithm = 'HS256';\n  }\n\n  var signingMethod = algorithmMap[algorithm];\n  var signingType = typeMap[algorithm];\n  if (!signingMethod || !signingType) {\n    throw new Error('Algorithm not supported');\n  }\n\n  // header, typ is fixed value.\n  var header = { typ: 'JWT', alg: algorithm };\n  if (options && options.header) {\n    assignProperties(header, options.header);\n  }\n\n  // create segments, all segments should be base64 string\n  var segments = [];\n  segments.push(base64urlEncode(JSON.stringify(header)));\n  segments.push(base64urlEncode(JSON.stringify(payload)));\n  segments.push(sign(segments.join('.'), key, signingMethod, signingType));\n\n  return segments.join('.');\n};\n\n/**\n * private util functions\n */\n\nfunction assignProperties(dest, source) {\n  for (var attr in source) {\n    if (source.hasOwnProperty(attr)) {\n      dest[attr] = source[attr];\n    }\n  }\n}\n\nfunction verify(input, key, method, type, signature) {\n  if(type === \"hmac\") {\n    return (signature === sign(input, key, method, type));\n  }\n  else if(type == \"sign\") {\n    return crypto.createVerify(method)\n                 .update(input)\n                 .verify(key, base64urlUnescape(signature), 'base64');\n  }\n  else {\n    throw new Error('Algorithm type not recognized');\n  }\n}\n\nfunction sign(input, key, method, type) {\n  var base64str;\n  if(type === \"hmac\") {\n    base64str = crypto.createHmac(method, key).update(input).digest('base64');\n  }\n  else if(type == \"sign\") {\n    base64str = crypto.createSign(method).update(input).sign(key, 'base64');\n  }\n  else {\n    throw new Error('Algorithm type not recognized');\n  }\n\n  return base64urlEscape(base64str);\n}\n\nfunction base64urlDecode(str) {\n  return Buffer.from(base64urlUnescape(str), 'base64').toString();\n}\n\nfunction base64urlUnescape(str) {\n  str += new Array(5 - str.length % 4).join('=');\n  return str.replace(/\\-/g, '+').replace(/_/g, '/');\n}\n\nfunction base64urlEncode(str) {\n  return base64urlEscape(Buffer.from(str).toString('base64'));\n}\n\nfunction base64urlEscape(str) {\n  return str.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n"]},"metadata":{},"sourceType":"script"}