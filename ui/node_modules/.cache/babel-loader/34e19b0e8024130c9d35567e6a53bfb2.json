{"ast":null,"code":"/**\r\n * Wraps values in an `Ok` type.\r\n *\r\n * Example: `ok(5) // => {ok: true, result: 5}`\r\n */\nvar ok = function (result) {\n  return {\n    ok: true,\n    result: result\n  };\n};\n/**\r\n * Typeguard for `Ok`.\r\n */\n\n\nvar isOk = function (r) {\n  return r.ok === true;\n};\n/**\r\n * Wraps errors in an `Err` type.\r\n *\r\n * Example: `err('on fire') // => {ok: false, error: 'on fire'}`\r\n */\n\n\nvar err = function (error) {\n  return {\n    ok: false,\n    error: error\n  };\n};\n/**\r\n * Typeguard for `Err`.\r\n */\n\n\nvar isErr = function (r) {\n  return r.ok === false;\n};\n/**\r\n * Create a `Promise` that either resolves with the result of `Ok` or rejects\r\n * with the error of `Err`.\r\n */\n\n\nvar asPromise = function (r) {\n  return r.ok === true ? Promise.resolve(r.result) : Promise.reject(r.error);\n};\n/**\r\n * Unwraps a `Result` and returns either the result of an `Ok`, or\r\n * `defaultValue`.\r\n *\r\n * Example:\r\n * ```\r\n * Result.withDefault(5, number().run(json))\r\n * ```\r\n *\r\n * It would be nice if `Decoder` had an instance method that mirrored this\r\n * function. Such a method would look something like this:\r\n * ```\r\n * class Decoder<A> {\r\n *   runWithDefault = (defaultValue: A, json: any): A =>\r\n *     Result.withDefault(defaultValue, this.run(json));\r\n * }\r\n *\r\n * number().runWithDefault(5, json)\r\n * ```\r\n * Unfortunately, the type of `defaultValue: A` on the method causes issues\r\n * with type inference on  the `object` decoder in some situations. While these\r\n * inference issues can be solved by providing the optional type argument for\r\n * `object`s, the extra trouble and confusion doesn't seem worth it.\r\n */\n\n\nvar withDefault = function (defaultValue, r) {\n  return r.ok === true ? r.result : defaultValue;\n};\n/**\r\n * Return the successful result, or throw an error.\r\n */\n\n\nvar withException = function (r) {\n  if (r.ok === true) {\n    return r.result;\n  } else {\n    throw r.error;\n  }\n};\n/**\r\n * Given an array of `Result`s, return the successful values.\r\n */\n\n\nvar successes = function (results) {\n  return results.reduce(function (acc, r) {\n    return r.ok === true ? acc.concat(r.result) : acc;\n  }, []);\n};\n/**\r\n * Apply `f` to the result of an `Ok`, or pass the error through.\r\n */\n\n\nvar map = function (f, r) {\n  return r.ok === true ? ok(f(r.result)) : r;\n};\n/**\r\n * Apply `f` to the result of two `Ok`s, or pass an error through. If both\r\n * `Result`s are errors then the first one is returned.\r\n */\n\n\nvar map2 = function (f, ar, br) {\n  return ar.ok === false ? ar : br.ok === false ? br : ok(f(ar.result, br.result));\n};\n/**\r\n * Apply `f` to the error of an `Err`, or pass the success through.\r\n */\n\n\nvar mapError = function (f, r) {\n  return r.ok === true ? r : err(f(r.error));\n};\n/**\r\n * Chain together a sequence of computations that may fail, similar to a\r\n * `Promise`. If the first computation fails then the error will propagate\r\n * through. If it succeeds, then `f` will be applied to the value, returning a\r\n * new `Result`.\r\n */\n\n\nvar andThen = function (f, r) {\n  return r.ok === true ? f(r.result) : r;\n};\n\nvar result = Object.freeze({\n  ok: ok,\n  isOk: isOk,\n  err: err,\n  isErr: isErr,\n  asPromise: asPromise,\n  withDefault: withDefault,\n  withException: withException,\n  successes: successes,\n  map: map,\n  map2: map2,\n  mapError: mapError,\n  andThen: andThen\n});\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n}\n\nvar isEqual = require('lodash.isequal'); // this syntax avoids TS1192\n\n/**\r\n * Type guard for `DecoderError`. One use case of the type guard is in the\r\n * `catch` of a promise. Typescript types the error argument of `catch` as\r\n * `any`, so when dealing with a decoder as a promise you may need to\r\n * distinguish between a `DecoderError` and an error string.\r\n */\n\n\nvar isDecoderError = function (a) {\n  return a.kind === 'DecoderError' && typeof a.at === 'string' && typeof a.message === 'string';\n};\n/*\r\n * Helpers\r\n */\n\n\nvar isJsonArray = function (json) {\n  return Array.isArray(json);\n};\n\nvar isJsonObject = function (json) {\n  return typeof json === 'object' && json !== null && !isJsonArray(json);\n};\n\nvar typeString = function (json) {\n  switch (typeof json) {\n    case 'string':\n      return 'a string';\n\n    case 'number':\n      return 'a number';\n\n    case 'boolean':\n      return 'a boolean';\n\n    case 'undefined':\n      return 'undefined';\n\n    case 'object':\n      if (json instanceof Array) {\n        return 'an array';\n      } else if (json === null) {\n        return 'null';\n      } else {\n        return 'an object';\n      }\n\n    default:\n      return JSON.stringify(json);\n  }\n};\n\nvar expectedGot = function (expected, got) {\n  return \"expected \" + expected + \", got \" + typeString(got);\n};\n\nvar printPath = function (paths) {\n  return paths.map(function (path) {\n    return typeof path === 'string' ? \".\" + path : \"[\" + path + \"]\";\n  }).join('');\n};\n\nvar prependAt = function (newAt, _a) {\n  var at = _a.at,\n      rest = __rest(_a, [\"at\"]);\n\n  return __assign({\n    at: newAt + (at || '')\n  }, rest);\n};\n/**\r\n * Decoders transform json objects with unknown structure into known and\r\n * verified forms. You can create objects of type `Decoder<A>` with either the\r\n * primitive decoder functions, such as `boolean()` and `string()`, or by\r\n * applying higher-order decoders to the primitives, such as `array(boolean())`\r\n * or `dict(string())`.\r\n *\r\n * Each of the decoder functions are available both as a static method on\r\n * `Decoder` and as a function alias -- for example the string decoder is\r\n * defined at `Decoder.string()`, but is also aliased to `string()`. Using the\r\n * function aliases exported with the library is recommended.\r\n *\r\n * `Decoder` exposes a number of 'run' methods, which all decode json in the\r\n * same way, but communicate success and failure in different ways. The `map`\r\n * and `andThen` methods modify decoders without having to call a 'run' method.\r\n *\r\n * Alternatively, the main decoder `run()` method returns an object of type\r\n * `Result<A, DecoderError>`. This library provides a number of helper\r\n * functions for dealing with the `Result` type, so you can do all the same\r\n * things with a `Result` as with the decoder methods.\r\n */\n\n\nvar Decoder =\n/** @class */\nfunction () {\n  /**\r\n   * The Decoder class constructor is kept private to separate the internal\r\n   * `decode` function from the external `run` function. The distinction\r\n   * between the two functions is that `decode` returns a\r\n   * `Partial<DecoderError>` on failure, which contains an unfinished error\r\n   * report. When `run` is called on a decoder, the relevant series of `decode`\r\n   * calls is made, and then on failure the resulting `Partial<DecoderError>`\r\n   * is turned into a `DecoderError` by filling in the missing information.\r\n   *\r\n   * While hiding the constructor may seem restrictive, leveraging the\r\n   * provided decoder combinators and helper functions such as\r\n   * `andThen` and `map` should be enough to build specialized decoders as\r\n   * needed.\r\n   */\n  function Decoder(decode) {\n    var _this = this;\n\n    this.decode = decode;\n    /**\r\n     * Run the decoder and return a `Result` with either the decoded value or a\r\n     * `DecoderError` containing the json input, the location of the error, and\r\n     * the error message.\r\n     *\r\n     * Examples:\r\n     * ```\r\n     * number().run(12)\r\n     * // => {ok: true, result: 12}\r\n     *\r\n     * string().run(9001)\r\n     * // =>\r\n     * // {\r\n     * //   ok: false,\r\n     * //   error: {\r\n     * //     kind: 'DecoderError',\r\n     * //     input: 9001,\r\n     * //     at: 'input',\r\n     * //     message: 'expected a string, got 9001'\r\n     * //   }\r\n     * // }\r\n     * ```\r\n     */\n\n    this.run = function (json) {\n      return mapError(function (error) {\n        return {\n          kind: 'DecoderError',\n          input: json,\n          at: 'input' + (error.at || ''),\n          message: error.message || ''\n        };\n      }, _this.decode(json));\n    };\n    /**\r\n     * Run the decoder as a `Promise`.\r\n     */\n\n\n    this.runPromise = function (json) {\n      return asPromise(_this.run(json));\n    };\n    /**\r\n     * Run the decoder and return the value on success, or throw an exception\r\n     * with a formatted error string.\r\n     */\n\n\n    this.runWithException = function (json) {\n      return withException(_this.run(json));\n    };\n    /**\r\n     * Construct a new decoder that applies a transformation to the decoded\r\n     * result. If the decoder succeeds then `f` will be applied to the value. If\r\n     * it fails the error will propagated through.\r\n     *\r\n     * Example:\r\n     * ```\r\n     * number().map(x => x * 5).run(10)\r\n     * // => {ok: true, result: 50}\r\n     * ```\r\n     */\n\n\n    this.map = function (f) {\n      return new Decoder(function (json) {\n        return map(f, _this.decode(json));\n      });\n    };\n    /**\r\n     * Chain together a sequence of decoders. The first decoder will run, and\r\n     * then the function will determine what decoder to run second. If the result\r\n     * of the first decoder succeeds then `f` will be applied to the decoded\r\n     * value. If it fails the error will propagate through.\r\n     *\r\n     * This is a very powerful method -- it can act as both the `map` and `where`\r\n     * methods, can improve error messages for edge cases, and can be used to\r\n     * make a decoder for custom types.\r\n     *\r\n     * Example of adding an error message:\r\n     * ```\r\n     * const versionDecoder = valueAt(['version'], number());\r\n     * const infoDecoder3 = object({a: boolean()});\r\n     *\r\n     * const decoder = versionDecoder.andThen(version => {\r\n     *   switch (version) {\r\n     *     case 3:\r\n     *       return infoDecoder3;\r\n     *     default:\r\n     *       return fail(`Unable to decode info, version ${version} is not supported.`);\r\n     *   }\r\n     * });\r\n     *\r\n     * decoder.run({version: 3, a: true})\r\n     * // => {ok: true, result: {a: true}}\r\n     *\r\n     * decoder.run({version: 5, x: 'abc'})\r\n     * // =>\r\n     * // {\r\n     * //   ok: false,\r\n     * //   error: {... message: 'Unable to decode info, version 5 is not supported.'}\r\n     * // }\r\n     * ```\r\n     *\r\n     * Example of decoding a custom type:\r\n     * ```\r\n     * // nominal type for arrays with a length of at least one\r\n     * type NonEmptyArray<T> = T[] & { __nonEmptyArrayBrand__: void };\r\n     *\r\n     * const nonEmptyArrayDecoder = <T>(values: Decoder<T>): Decoder<NonEmptyArray<T>> =>\r\n     *   array(values).andThen(arr =>\r\n     *     arr.length > 0\r\n     *       ? succeed(createNonEmptyArray(arr))\r\n     *       : fail(`expected a non-empty array, got an empty array`)\r\n     *   );\r\n     * ```\r\n     */\n\n\n    this.andThen = function (f) {\n      return new Decoder(function (json) {\n        return andThen(function (value) {\n          return f(value).decode(json);\n        }, _this.decode(json));\n      });\n    };\n    /**\r\n     * Add constraints to a decoder _without_ changing the resulting type. The\r\n     * `test` argument is a predicate function which returns true for valid\r\n     * inputs. When `test` fails on an input, the decoder fails with the given\r\n     * `errorMessage`.\r\n     *\r\n     * ```\r\n     * const chars = (length: number): Decoder<string> =>\r\n     *   string().where(\r\n     *     (s: string) => s.length === length,\r\n     *     `expected a string of length ${length}`\r\n     *   );\r\n     *\r\n     * chars(5).run('12345')\r\n     * // => {ok: true, result: '12345'}\r\n     *\r\n     * chars(2).run('HELLO')\r\n     * // => {ok: false, error: {... message: 'expected a string of length 2'}}\r\n     *\r\n     * chars(12).run(true)\r\n     * // => {ok: false, error: {... message: 'expected a string, got a boolean'}}\r\n     * ```\r\n     */\n\n\n    this.where = function (test, errorMessage) {\n      return _this.andThen(function (value) {\n        return test(value) ? Decoder.succeed(value) : Decoder.fail(errorMessage);\n      });\n    };\n  }\n  /**\r\n   * Decoder primitive that validates strings, and fails on all other input.\r\n   */\n\n\n  Decoder.string = function () {\n    return new Decoder(function (json) {\n      return typeof json === 'string' ? ok(json) : err({\n        message: expectedGot('a string', json)\n      });\n    });\n  };\n  /**\r\n   * Decoder primitive that validates numbers, and fails on all other input.\r\n   */\n\n\n  Decoder.number = function () {\n    return new Decoder(function (json) {\n      return typeof json === 'number' ? ok(json) : err({\n        message: expectedGot('a number', json)\n      });\n    });\n  };\n  /**\r\n   * Decoder primitive that validates booleans, and fails on all other input.\r\n   */\n\n\n  Decoder.boolean = function () {\n    return new Decoder(function (json) {\n      return typeof json === 'boolean' ? ok(json) : err({\n        message: expectedGot('a boolean', json)\n      });\n    });\n  };\n\n  Decoder.constant = function (value) {\n    return new Decoder(function (json) {\n      return isEqual(json, value) ? ok(value) : err({\n        message: \"expected \" + JSON.stringify(value) + \", got \" + JSON.stringify(json)\n      });\n    });\n  };\n\n  Decoder.object = function (decoders) {\n    return new Decoder(function (json) {\n      if (isJsonObject(json) && decoders) {\n        var obj = {};\n\n        for (var key in decoders) {\n          if (decoders.hasOwnProperty(key)) {\n            var r = decoders[key].decode(json[key]);\n\n            if (r.ok === true) {\n              // tslint:disable-next-line:strict-type-predicates\n              if (r.result !== undefined) {\n                obj[key] = r.result;\n              }\n            } else if (json[key] === undefined) {\n              return err({\n                message: \"the key '\" + key + \"' is required but was not present\"\n              });\n            } else {\n              return err(prependAt(\".\" + key, r.error));\n            }\n          }\n        }\n\n        return ok(obj);\n      } else if (isJsonObject(json)) {\n        return ok(json);\n      } else {\n        return err({\n          message: expectedGot('an object', json)\n        });\n      }\n    });\n  };\n\n  Decoder.array = function (decoder) {\n    return new Decoder(function (json) {\n      if (isJsonArray(json) && decoder) {\n        var decodeValue_1 = function (v, i) {\n          return mapError(function (err$$1) {\n            return prependAt(\"[\" + i + \"]\", err$$1);\n          }, decoder.decode(v));\n        };\n\n        return json.reduce(function (acc, v, i) {\n          return map2(function (arr, result) {\n            return arr.concat([result]);\n          }, acc, decodeValue_1(v, i));\n        }, ok([]));\n      } else if (isJsonArray(json)) {\n        return ok(json);\n      } else {\n        return err({\n          message: expectedGot('an array', json)\n        });\n      }\n    });\n  };\n\n  Decoder.tuple = function (decoders) {\n    return new Decoder(function (json) {\n      if (isJsonArray(json)) {\n        if (json.length !== decoders.length) {\n          return err({\n            message: \"expected a tuple of length \" + decoders.length + \", got one of length \" + json.length\n          });\n        }\n\n        var result = [];\n\n        for (var i = 0; i < decoders.length; i++) {\n          var nth = decoders[i].decode(json[i]);\n\n          if (nth.ok) {\n            result[i] = nth.result;\n          } else {\n            return err(prependAt(\"[\" + i + \"]\", nth.error));\n          }\n        }\n\n        return ok(result);\n      } else {\n        return err({\n          message: expectedGot(\"a tuple of length \" + decoders.length, json)\n        });\n      }\n    });\n  };\n\n  Decoder.union = function (ad, bd) {\n    var decoders = [];\n\n    for (var _i = 2; _i < arguments.length; _i++) {\n      decoders[_i - 2] = arguments[_i];\n    }\n\n    return Decoder.oneOf.apply(Decoder, [ad, bd].concat(decoders));\n  };\n\n  Decoder.intersection = function (ad, bd) {\n    var ds = [];\n\n    for (var _i = 2; _i < arguments.length; _i++) {\n      ds[_i - 2] = arguments[_i];\n    }\n\n    return new Decoder(function (json) {\n      return [ad, bd].concat(ds).reduce(function (acc, decoder) {\n        return map2(Object.assign, acc, decoder.decode(json));\n      }, ok({}));\n    });\n  };\n  /**\r\n   * Escape hatch to bypass validation. Always succeeds and types the result as\r\n   * `any`. Useful for defining decoders incrementally, particularly for\r\n   * complex objects.\r\n   *\r\n   * Example:\r\n   * ```\r\n   * interface User {\r\n   *   name: string;\r\n   *   complexUserData: ComplexType;\r\n   * }\r\n   *\r\n   * const userDecoder: Decoder<User> = object({\r\n   *   name: string(),\r\n   *   complexUserData: anyJson()\r\n   * });\r\n   * ```\r\n   */\n\n\n  Decoder.anyJson = function () {\n    return new Decoder(function (json) {\n      return ok(json);\n    });\n  };\n  /**\r\n   * Decoder identity function which always succeeds and types the result as\r\n   * `unknown`.\r\n   */\n\n\n  Decoder.unknownJson = function () {\n    return new Decoder(function (json) {\n      return ok(json);\n    });\n  };\n  /**\r\n   * Decoder for json objects where the keys are unknown strings, but the values\r\n   * should all be of the same type.\r\n   *\r\n   * Example:\r\n   * ```\r\n   * dict(number()).run({chocolate: 12, vanilla: 10, mint: 37});\r\n   * // => {ok: true, result: {chocolate: 12, vanilla: 10, mint: 37}}\r\n   * ```\r\n   */\n\n\n  Decoder.dict = function (decoder) {\n    return new Decoder(function (json) {\n      if (isJsonObject(json)) {\n        var obj = {};\n\n        for (var key in json) {\n          if (json.hasOwnProperty(key)) {\n            var r = decoder.decode(json[key]);\n\n            if (r.ok === true) {\n              obj[key] = r.result;\n            } else {\n              return err(prependAt(\".\" + key, r.error));\n            }\n          }\n        }\n\n        return ok(obj);\n      } else {\n        return err({\n          message: expectedGot('an object', json)\n        });\n      }\n    });\n  };\n  /**\r\n   * Decoder for values that may be `undefined`. This is primarily helpful for\r\n   * decoding interfaces with optional fields.\r\n   *\r\n   * Example:\r\n   * ```\r\n   * interface User {\r\n   *   id: number;\r\n   *   isOwner?: boolean;\r\n   * }\r\n   *\r\n   * const decoder: Decoder<User> = object({\r\n   *   id: number(),\r\n   *   isOwner: optional(boolean())\r\n   * });\r\n   * ```\r\n   */\n\n\n  Decoder.optional = function (decoder) {\n    return new Decoder(function (json) {\n      return json === undefined ? ok(undefined) : decoder.decode(json);\n    });\n  };\n  /**\r\n   * Decoder that attempts to run each decoder in `decoders` and either succeeds\r\n   * with the first successful decoder, or fails after all decoders have failed.\r\n   *\r\n   * Note that `oneOf` expects the decoders to all have the same return type,\r\n   * while `union` creates a decoder for the union type of all the input\r\n   * decoders.\r\n   *\r\n   * Examples:\r\n   * ```\r\n   * oneOf(string(), number().map(String))\r\n   * oneOf(constant('start'), constant('stop'), succeed('unknown'))\r\n   * ```\r\n   */\n\n\n  Decoder.oneOf = function () {\n    var decoders = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      decoders[_i] = arguments[_i];\n    }\n\n    return new Decoder(function (json) {\n      var errors = [];\n\n      for (var i = 0; i < decoders.length; i++) {\n        var r = decoders[i].decode(json);\n\n        if (r.ok === true) {\n          return r;\n        } else {\n          errors[i] = r.error;\n        }\n      }\n\n      var errorsList = errors.map(function (error) {\n        return \"at error\" + (error.at || '') + \": \" + error.message;\n      }).join('\", \"');\n      return err({\n        message: \"expected a value matching one of the decoders, got the errors [\\\"\" + errorsList + \"\\\"]\"\n      });\n    });\n  };\n  /**\r\n   * Decoder that always succeeds with either the decoded value, or a fallback\r\n   * default value.\r\n   */\n\n\n  Decoder.withDefault = function (defaultValue, decoder) {\n    return new Decoder(function (json) {\n      return ok(withDefault(defaultValue, decoder.decode(json)));\n    });\n  };\n  /**\r\n   * Decoder that pulls a specific field out of a json structure, instead of\r\n   * decoding and returning the full structure. The `paths` array describes the\r\n   * object keys and array indices to traverse, so that values can be pulled out\r\n   * of a nested structure.\r\n   *\r\n   * Example:\r\n   * ```\r\n   * const decoder = valueAt(['a', 'b', 0], string());\r\n   *\r\n   * decoder.run({a: {b: ['surprise!']}})\r\n   * // => {ok: true, result: 'surprise!'}\r\n   *\r\n   * decoder.run({a: {x: 'cats'}})\r\n   * // => {ok: false, error: {... at: 'input.a.b[0]' message: 'path does not exist'}}\r\n   * ```\r\n   *\r\n   * Note that the `decoder` is ran on the value found at the last key in the\r\n   * path, even if the last key is not found. This allows the `optional`\r\n   * decoder to succeed when appropriate.\r\n   * ```\r\n   * const optionalDecoder = valueAt(['a', 'b', 'c'], optional(string()));\r\n   *\r\n   * optionalDecoder.run({a: {b: {c: 'surprise!'}}})\r\n   * // => {ok: true, result: 'surprise!'}\r\n   *\r\n   * optionalDecoder.run({a: {b: 'cats'}})\r\n   * // => {ok: false, error: {... at: 'input.a.b.c' message: 'expected an object, got \"cats\"'}\r\n   *\r\n   * optionalDecoder.run({a: {b: {z: 1}}})\r\n   * // => {ok: true, result: undefined}\r\n   * ```\r\n   */\n\n\n  Decoder.valueAt = function (paths, decoder) {\n    return new Decoder(function (json) {\n      var jsonAtPath = json;\n\n      for (var i = 0; i < paths.length; i++) {\n        if (jsonAtPath === undefined) {\n          return err({\n            at: printPath(paths.slice(0, i + 1)),\n            message: 'path does not exist'\n          });\n        } else if (typeof paths[i] === 'string' && !isJsonObject(jsonAtPath)) {\n          return err({\n            at: printPath(paths.slice(0, i + 1)),\n            message: expectedGot('an object', jsonAtPath)\n          });\n        } else if (typeof paths[i] === 'number' && !isJsonArray(jsonAtPath)) {\n          return err({\n            at: printPath(paths.slice(0, i + 1)),\n            message: expectedGot('an array', jsonAtPath)\n          });\n        } else {\n          jsonAtPath = jsonAtPath[paths[i]];\n        }\n      }\n\n      return mapError(function (error) {\n        return jsonAtPath === undefined ? {\n          at: printPath(paths),\n          message: 'path does not exist'\n        } : prependAt(printPath(paths), error);\n      }, decoder.decode(jsonAtPath));\n    });\n  };\n  /**\r\n   * Decoder that ignores the input json and always succeeds with `fixedValue`.\r\n   */\n\n\n  Decoder.succeed = function (fixedValue) {\n    return new Decoder(function (json) {\n      return ok(fixedValue);\n    });\n  };\n  /**\r\n   * Decoder that ignores the input json and always fails with `errorMessage`.\r\n   */\n\n\n  Decoder.fail = function (errorMessage) {\n    return new Decoder(function (json) {\n      return err({\n        message: errorMessage\n      });\n    });\n  };\n  /**\r\n   * Decoder that allows for validating recursive data structures. Unlike with\r\n   * functions, decoders assigned to variables can't reference themselves\r\n   * before they are fully defined. We can avoid prematurely referencing the\r\n   * decoder by wrapping it in a function that won't be called until use, at\r\n   * which point the decoder has been defined.\r\n   *\r\n   * Example:\r\n   * ```\r\n   * interface Comment {\r\n   *   msg: string;\r\n   *   replies: Comment[];\r\n   * }\r\n   *\r\n   * const decoder: Decoder<Comment> = object({\r\n   *   msg: string(),\r\n   *   replies: lazy(() => array(decoder))\r\n   * });\r\n   * ```\r\n   */\n\n\n  Decoder.lazy = function (mkDecoder) {\n    return new Decoder(function (json) {\n      return mkDecoder().decode(json);\n    });\n  };\n\n  return Decoder;\n}();\n/* tslint:disable:variable-name */\n\n/** See `Decoder.string` */\n\n\nvar string = Decoder.string;\n/** See `Decoder.number` */\n\nvar number = Decoder.number;\n/** See `Decoder.boolean` */\n\nvar boolean = Decoder.boolean;\n/** See `Decoder.anyJson` */\n\nvar anyJson = Decoder.anyJson;\n/** See `Decoder.unknownJson` */\n\nvar unknownJson = Decoder.unknownJson;\n/** See `Decoder.constant` */\n\nvar constant = Decoder.constant;\n/** See `Decoder.object` */\n\nvar object = Decoder.object;\n/** See `Decoder.array` */\n\nvar array = Decoder.array;\n/** See `Decoder.tuple` */\n\nvar tuple = Decoder.tuple;\n/** See `Decoder.dict` */\n\nvar dict = Decoder.dict;\n/** See `Decoder.optional` */\n\nvar optional = Decoder.optional;\n/** See `Decoder.oneOf` */\n\nvar oneOf = Decoder.oneOf;\n/** See `Decoder.union` */\n\nvar union = Decoder.union;\n/** See `Decoder.intersection` */\n\nvar intersection = Decoder.intersection;\n/** See `Decoder.withDefault` */\n\nvar withDefault$1 = Decoder.withDefault;\n/** See `Decoder.valueAt` */\n\nvar valueAt = Decoder.valueAt;\n/** See `Decoder.succeed` */\n\nvar succeed = Decoder.succeed;\n/** See `Decoder.fail` */\n\nvar fail = Decoder.fail;\n/** See `Decoder.lazy` */\n\nvar lazy = Decoder.lazy;\nexport { result as Result, Decoder, isDecoderError, string, number, boolean, anyJson, unknownJson, constant, object, array, tuple, dict, optional, oneOf, union, intersection, withDefault$1 as withDefault, valueAt, succeed, fail, lazy };","map":{"version":3,"sources":["../src/result.ts","../src/decoder.ts","../src/combinators.ts"],"names":["Result.ok","Result.err","err","Result.withDefault","Result.mapError","withDefault"],"mappings":"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","sourcesContent":["/**\n * The result of a computation that may fail. The decoding function\n * `Decoder.run` returns a `Result`. The value of a `Result` is either `Ok` if\n * the computation succeeded, or `Err` if there was some failure in the\n * process.\n */\nexport type Result<V, E> = Ok<V> | Err<E>;\n\n/**\n * The success type variant for `Result`. Denotes that a result value was\n * computed with no errors.\n */\nexport interface Ok<V> {\n  ok: true;\n  result: V;\n}\n\n/**\n * The error type variant for `Result`. Denotes that some error occurred before\n * the result was computed.\n */\nexport interface Err<E> {\n  ok: false;\n  error: E;\n}\n\n/**\n * Wraps values in an `Ok` type.\n *\n * Example: `ok(5) // => {ok: true, result: 5}`\n */\nexport const ok = <V>(result: V): Ok<V> => ({ok: true, result: result});\n\n/**\n * Typeguard for `Ok`.\n */\nexport const isOk = <V>(r: Result<V, any>): r is Ok<V> => r.ok === true;\n\n/**\n * Wraps errors in an `Err` type.\n *\n * Example: `err('on fire') // => {ok: false, error: 'on fire'}`\n */\nexport const err = <E>(error: E): Err<E> => ({ok: false, error: error});\n\n/**\n * Typeguard for `Err`.\n */\nexport const isErr = <E>(r: Result<any, E>): r is Err<E> => r.ok === false;\n\n/**\n * Create a `Promise` that either resolves with the result of `Ok` or rejects\n * with the error of `Err`.\n */\nexport const asPromise = <V>(r: Result<V, any>): Promise<V> =>\n  r.ok === true ? Promise.resolve(r.result) : Promise.reject(r.error);\n\n/**\n * Unwraps a `Result` and returns either the result of an `Ok`, or\n * `defaultValue`.\n *\n * Example:\n * ```\n * Result.withDefault(5, number().run(json))\n * ```\n *\n * It would be nice if `Decoder` had an instance method that mirrored this\n * function. Such a method would look something like this:\n * ```\n * class Decoder<A> {\n *   runWithDefault = (defaultValue: A, json: any): A =>\n *     Result.withDefault(defaultValue, this.run(json));\n * }\n *\n * number().runWithDefault(5, json)\n * ```\n * Unfortunately, the type of `defaultValue: A` on the method causes issues\n * with type inference on  the `object` decoder in some situations. While these\n * inference issues can be solved by providing the optional type argument for\n * `object`s, the extra trouble and confusion doesn't seem worth it.\n */\nexport const withDefault = <V>(defaultValue: V, r: Result<V, any>): V =>\n  r.ok === true ? r.result : defaultValue;\n\n/**\n * Return the successful result, or throw an error.\n */\nexport const withException = <V>(r: Result<V, any>): V => {\n  if (r.ok === true) {\n    return r.result;\n  } else {\n    throw r.error;\n  }\n};\n\n/**\n * Given an array of `Result`s, return the successful values.\n */\nexport const successes = <A>(results: Result<A, any>[]): A[] =>\n  results.reduce((acc: A[], r: Result<A, any>) => (r.ok === true ? acc.concat(r.result) : acc), []);\n\n/**\n * Apply `f` to the result of an `Ok`, or pass the error through.\n */\nexport const map = <A, B, E>(f: (value: A) => B, r: Result<A, E>): Result<B, E> =>\n  r.ok === true ? ok<B>(f(r.result)) : r;\n\n/**\n * Apply `f` to the result of two `Ok`s, or pass an error through. If both\n * `Result`s are errors then the first one is returned.\n */\nexport const map2 = <A, B, C, E>(f: (av: A, bv: B) => C, ar: Result<A, E>, br: Result<B, E>): Result<C, E> =>\n  ar.ok === false ? ar :\n    br.ok === false ? br :\n      ok<C>(f(ar.result, br.result));\n\n/**\n * Apply `f` to the error of an `Err`, or pass the success through.\n */\nexport const mapError = <V, A, B>(f: (error: A) => B, r: Result<V, A>): Result<V, B> =>\n  r.ok === true ? r : err<B>(f(r.error));\n\n/**\n * Chain together a sequence of computations that may fail, similar to a\n * `Promise`. If the first computation fails then the error will propagate\n * through. If it succeeds, then `f` will be applied to the value, returning a\n * new `Result`.\n */\nexport const andThen = <A, B, E>(f: (value: A) => Result<B, E>, r: Result<A, E>): Result<B, E> =>\n  r.ok === true ? f(r.result) : r;\n","import * as Result from './result';\nconst isEqual = require('lodash.isequal'); // this syntax avoids TS1192\n\n/**\n * Information describing how json data failed to match a decoder.\n * Includes the full input json, since in most cases it's useless to know how a\n * decoder failed without also seeing the malformed data.\n */\nexport interface DecoderError {\n  kind: 'DecoderError';\n  input: unknown;\n  at: string;\n  message: string;\n}\n\n/**\n * Alias for the result of the `Decoder.run` method. On success returns `Ok`\n * with the decoded value of type `A`, on failure returns `Err` containing a\n * `DecoderError`.\n */\ntype RunResult<A> = Result.Result<A, DecoderError>;\n\n/**\n * Alias for the result of the internal `Decoder.decode` method. Since `decode`\n * is a private function it returns a partial decoder error on failure, which\n * will be completed and polished when handed off to the `run` method.\n */\ntype DecodeResult<A> = Result.Result<A, Partial<DecoderError>>;\n\n/**\n * Defines a mapped type over an interface `A`. `DecoderObject<A>` is an\n * interface that has all the keys or `A`, but each key's property type is\n * mapped to a decoder for that type. This type is used when creating decoders\n * for objects.\n *\n * Example:\n * ```\n * interface X {\n *   a: boolean;\n *   b: string;\n * }\n *\n * const decoderObject: DecoderObject<X> = {\n *   a: boolean(),\n *   b: string()\n * }\n * ```\n */\nexport type DecoderObject<A> = {[t in keyof A]: Decoder<A[t]>};\n\n/**\n * Type guard for `DecoderError`. One use case of the type guard is in the\n * `catch` of a promise. Typescript types the error argument of `catch` as\n * `any`, so when dealing with a decoder as a promise you may need to\n * distinguish between a `DecoderError` and an error string.\n */\nexport const isDecoderError = (a: any): a is DecoderError =>\n  a.kind === 'DecoderError' && typeof a.at === 'string' && typeof a.message === 'string';\n\n/*\n * Helpers\n */\nconst isJsonArray = (json: any): json is unknown[] => Array.isArray(json);\n\nconst isJsonObject = (json: any): json is Record<string, unknown> =>\n  typeof json === 'object' && json !== null && !isJsonArray(json);\n\nconst typeString = (json: unknown): string => {\n  switch (typeof json) {\n    case 'string':\n      return 'a string';\n    case 'number':\n      return 'a number';\n    case 'boolean':\n      return 'a boolean';\n    case 'undefined':\n      return 'undefined';\n    case 'object':\n      if (json instanceof Array) {\n        return 'an array';\n      } else if (json === null) {\n        return 'null';\n      } else {\n        return 'an object';\n      }\n    default:\n      return JSON.stringify(json);\n  }\n};\n\nconst expectedGot = (expected: string, got: unknown) =>\n  `expected ${expected}, got ${typeString(got)}`;\n\nconst printPath = (paths: (string | number)[]): string =>\n  paths.map(path => (typeof path === 'string' ? `.${path}` : `[${path}]`)).join('');\n\nconst prependAt = (newAt: string, {at, ...rest}: Partial<DecoderError>): Partial<DecoderError> => ({\n  at: newAt + (at || ''),\n  ...rest\n});\n\n/**\n * Decoders transform json objects with unknown structure into known and\n * verified forms. You can create objects of type `Decoder<A>` with either the\n * primitive decoder functions, such as `boolean()` and `string()`, or by\n * applying higher-order decoders to the primitives, such as `array(boolean())`\n * or `dict(string())`.\n *\n * Each of the decoder functions are available both as a static method on\n * `Decoder` and as a function alias -- for example the string decoder is\n * defined at `Decoder.string()`, but is also aliased to `string()`. Using the\n * function aliases exported with the library is recommended.\n *\n * `Decoder` exposes a number of 'run' methods, which all decode json in the\n * same way, but communicate success and failure in different ways. The `map`\n * and `andThen` methods modify decoders without having to call a 'run' method.\n *\n * Alternatively, the main decoder `run()` method returns an object of type\n * `Result<A, DecoderError>`. This library provides a number of helper\n * functions for dealing with the `Result` type, so you can do all the same\n * things with a `Result` as with the decoder methods.\n */\nexport class Decoder<A> {\n  /**\n   * The Decoder class constructor is kept private to separate the internal\n   * `decode` function from the external `run` function. The distinction\n   * between the two functions is that `decode` returns a\n   * `Partial<DecoderError>` on failure, which contains an unfinished error\n   * report. When `run` is called on a decoder, the relevant series of `decode`\n   * calls is made, and then on failure the resulting `Partial<DecoderError>`\n   * is turned into a `DecoderError` by filling in the missing information.\n   *\n   * While hiding the constructor may seem restrictive, leveraging the\n   * provided decoder combinators and helper functions such as\n   * `andThen` and `map` should be enough to build specialized decoders as\n   * needed.\n   */\n  private constructor(private decode: (json: unknown) => DecodeResult<A>) {}\n\n  /**\n   * Decoder primitive that validates strings, and fails on all other input.\n   */\n  static string(): Decoder<string> {\n    return new Decoder<string>(\n      (json: unknown) =>\n        typeof json === 'string'\n          ? Result.ok(json)\n          : Result.err({message: expectedGot('a string', json)})\n    );\n  }\n\n  /**\n   * Decoder primitive that validates numbers, and fails on all other input.\n   */\n  static number(): Decoder<number> {\n    return new Decoder<number>(\n      (json: unknown) =>\n        typeof json === 'number'\n          ? Result.ok(json)\n          : Result.err({message: expectedGot('a number', json)})\n    );\n  }\n\n  /**\n   * Decoder primitive that validates booleans, and fails on all other input.\n   */\n  static boolean(): Decoder<boolean> {\n    return new Decoder<boolean>(\n      (json: unknown) =>\n        typeof json === 'boolean'\n          ? Result.ok(json)\n          : Result.err({message: expectedGot('a boolean', json)})\n    );\n  }\n\n  /**\n   * Escape hatch to bypass validation. Always succeeds and types the result as\n   * `any`. Useful for defining decoders incrementally, particularly for\n   * complex objects.\n   *\n   * Example:\n   * ```\n   * interface User {\n   *   name: string;\n   *   complexUserData: ComplexType;\n   * }\n   *\n   * const userDecoder: Decoder<User> = object({\n   *   name: string(),\n   *   complexUserData: anyJson()\n   * });\n   * ```\n   */\n  static anyJson = (): Decoder<any> => new Decoder<any>((json: any) => Result.ok(json));\n\n  /**\n   * Decoder identity function which always succeeds and types the result as\n   * `unknown`.\n   */\n  static unknownJson = (): Decoder<unknown> =>\n    new Decoder<unknown>((json: unknown) => Result.ok(json));\n\n  /**\n   * Decoder primitive that only matches on exact values.\n   *\n   * Note that `constant('string to match')` returns a `Decoder<string>` which\n   * fails if the input is not equal to `'string to match'`. In many cases this\n   * is sufficient, but in some situations typescript requires that the decoder\n   * type be a type-literal. In such a case you must provide the type parameter,\n   * which looks like `constant<'string to match'>('string to match')`.\n   *\n   * Providing the type parameter is only necessary for type-literal strings\n   * and numbers, as detailed by this table:\n   *\n   * ```\n   *  | Decoder                      | Type                 |\n   *  | ---------------------------- | ---------------------|\n   *  | constant(true)               | Decoder<true>        |\n   *  | constant(false)              | Decoder<false>       |\n   *  | constant(null)               | Decoder<null>        |\n   *  | constant('alaska')           | Decoder<string>      |\n   *  | constant<'alaska'>('alaska') | Decoder<'alaska'>    |\n   *  | constant(50)                 | Decoder<number>      |\n   *  | constant<50>(50)             | Decoder<50>          |\n   *  | constant([1,2,3])            | Decoder<number[]>    |\n   *  | constant<[1,2,3]>([1,2,3])   | Decoder<[1,2,3]>     |\n   *  | constant({x: 't'})           | Decoder<{x: string}> |\n   *  | constant<{x: 't'}>({x: 't'}) | Decoder<{x: 't'}>    |\n   * ```\n   *\n   *\n   * One place where this happens is when a type-literal is in an interface:\n   * ```\n   * interface Bear {\n   *   kind: 'bear';\n   *   isBig: boolean;\n   * }\n   *\n   * const bearDecoder1: Decoder<Bear> = object({\n   *   kind: constant('bear'),\n   *   isBig: boolean()\n   * });\n   * // Type 'Decoder<{ kind: string; isBig: boolean; }>' is not assignable to\n   * // type 'Decoder<Bear>'. Type 'string' is not assignable to type '\"bear\"'.\n   *\n   * const bearDecoder2: Decoder<Bear> = object({\n   *   kind: constant<'bear'>('bear'),\n   *   isBig: boolean()\n   * });\n   * // no compiler errors\n   * ```\n   *\n   * Another is in type-literal unions:\n   * ```\n   * type animal = 'bird' | 'bear';\n   *\n   * const animalDecoder1: Decoder<animal> = union(\n   *   constant('bird'),\n   *   constant('bear')\n   * );\n   * // Type 'Decoder<string>' is not assignable to type 'Decoder<animal>'.\n   * // Type 'string' is not assignable to type 'animal'.\n   *\n   * const animalDecoder2: Decoder<animal> = union(\n   *   constant<'bird'>('bird'),\n   *   constant<'bear'>('bear')\n   * );\n   * // no compiler errors\n   * ```\n   */\n  static constant(value: true): Decoder<true>;\n  static constant(value: false): Decoder<false>;\n  static constant<A>(value: A): Decoder<A>;\n  static constant(value: any): Decoder<any> {\n    return new Decoder(\n      (json: unknown) =>\n        isEqual(json, value)\n          ? Result.ok(value)\n          : Result.err({message: `expected ${JSON.stringify(value)}, got ${JSON.stringify(json)}`})\n    );\n  }\n\n  /**\n   * An higher-order decoder that runs decoders on specified fields of an object,\n   * and returns a new object with those fields. If `object` is called with no\n   * arguments, then the outer object part of the json is validated but not the\n   * contents, typing the result as a record where all keys have a value of\n   * type `unknown`.\n   *\n   * The `optional` and `constant` decoders are particularly useful for decoding\n   * objects that match typescript interfaces.\n   *\n   * To decode a single field that is inside of an object see `valueAt`.\n   *\n   * Example:\n   * ```\n   * object({x: number(), y: number()}).run({x: 5, y: 10})\n   * // => {ok: true, result: {x: 5, y: 10}}\n   *\n   * object().map(Object.keys).run({n: 1, i: [], c: {}, e: 'e'})\n   * // => {ok: true, result: ['n', 'i', 'c', 'e']}\n   * ```\n   */\n  static object(): Decoder<Record<string, unknown>>;\n  static object<A>(decoders: DecoderObject<A>): Decoder<A>;\n  static object<A>(decoders?: DecoderObject<A>) {\n    return new Decoder((json: unknown) => {\n      if (isJsonObject(json) && decoders) {\n        let obj: any = {};\n        for (const key in decoders) {\n          if (decoders.hasOwnProperty(key)) {\n            const r = decoders[key].decode(json[key]);\n            if (r.ok === true) {\n              // tslint:disable-next-line:strict-type-predicates\n              if (r.result !== undefined) {\n                obj[key] = r.result;\n              }\n            } else if (json[key] === undefined) {\n              return Result.err({message: `the key '${key}' is required but was not present`});\n            } else {\n              return Result.err(prependAt(`.${key}`, r.error));\n            }\n          }\n        }\n        return Result.ok(obj);\n      } else if (isJsonObject(json)) {\n        return Result.ok(json);\n      } else {\n        return Result.err({message: expectedGot('an object', json)});\n      }\n    });\n  }\n\n  /**\n   * Decoder for json arrays. Runs `decoder` on each array element, and succeeds\n   * if all elements are successfully decoded. If no `decoder` argument is\n   * provided then the outer array part of the json is validated but not the\n   * contents, typing the result as `unknown[]`.\n   *\n   * To decode a single value that is inside of an array see `valueAt`.\n   *\n   * Examples:\n   * ```\n   * array(number()).run([1, 2, 3])\n   * // => {ok: true, result: [1, 2, 3]}\n   *\n   * array(array(boolean())).run([[true], [], [true, false, false]])\n   * // => {ok: true, result: [[true], [], [true, false, false]]}\n   *\n   *\n   * const validNumbersDecoder = array()\n   *   .map((arr: unknown[]) => arr.map(number().run))\n   *   .map(Result.successes)\n   *\n   * validNumbersDecoder.run([1, true, 2, 3, 'five', 4, []])\n   * // {ok: true, result: [1, 2, 3, 4]}\n   *\n   * validNumbersDecoder.run([false, 'hi', {}])\n   * // {ok: true, result: []}\n   *\n   * validNumbersDecoder.run(false)\n   * // {ok: false, error: {..., message: \"expected an array, got a boolean\"}}\n   * ```\n   */\n  static array(): Decoder<unknown[]>;\n  static array<A>(decoder: Decoder<A>): Decoder<A[]>;\n  static array<A>(decoder?: Decoder<A>) {\n    return new Decoder(json => {\n      if (isJsonArray(json) && decoder) {\n        const decodeValue = (v: unknown, i: number): DecodeResult<A> =>\n          Result.mapError(err => prependAt(`[${i}]`, err), decoder.decode(v));\n\n        return json.reduce(\n          (acc: DecodeResult<A[]>, v: unknown, i: number) =>\n            Result.map2((arr, result) => [...arr, result], acc, decodeValue(v, i)),\n          Result.ok([])\n        );\n      } else if (isJsonArray(json)) {\n        return Result.ok(json);\n      } else {\n        return Result.err({message: expectedGot('an array', json)});\n      }\n    });\n  }\n\n  /**\n   * Decoder for fixed-length arrays, aka Tuples.\n   *\n   * Supports up to 8-tuples.\n   *\n   * Example:\n   * ```\n   * tuple([number(), number(), string()]).run([5, 10, 'px'])\n   * // => {ok: true, result: [5, 10, 'px']}\n   * ```\n   */\n  static tuple<A>(decoder: [Decoder<A>]): Decoder<[A]>;\n  static tuple<A, B>(decoder: [Decoder<A>, Decoder<B>]): Decoder<[A, B]>;\n  static tuple<A, B, C>(decoder: [Decoder<A>, Decoder<B>, Decoder<C>]): Decoder<[A, B, C]>;\n  static tuple<A, B, C, D>(decoder: [Decoder<A>, Decoder<B>, Decoder<C>, Decoder<D>]): Decoder<[A, B, C, D]>; // prettier-ignore\n  static tuple<A, B, C, D, E>(decoder: [Decoder<A>, Decoder<B>, Decoder<C>, Decoder<D>, Decoder<E>]): Decoder<[A, B, C, D, E]>; // prettier-ignore\n  static tuple<A, B, C, D, E, F>(decoder: [Decoder<A>, Decoder<B>, Decoder<C>, Decoder<D>, Decoder<E>, Decoder<F>]): Decoder<[A, B, C, D, E, F]>; // prettier-ignore\n  static tuple<A, B, C, D, E, F, G>(decoder: [Decoder<A>, Decoder<B>, Decoder<C>, Decoder<D>, Decoder<E>, Decoder<F>, Decoder<G>]): Decoder<[A, B, C, D, E, F, G]>; // prettier-ignore\n  static tuple<A, B, C, D, E, F, G, H>(decoder: [Decoder<A>, Decoder<B>, Decoder<C>, Decoder<D>, Decoder<E>, Decoder<F>, Decoder<G>, Decoder<H>]): Decoder<[A, B, C, D, E, F, G, H]>; // prettier-ignore\n  static tuple<A>(decoders: Decoder<A>[]) {\n    return new Decoder((json: unknown) => {\n      if (isJsonArray(json)) {\n        if (json.length !== decoders.length) {\n          return Result.err({\n            message: `expected a tuple of length ${decoders.length}, got one of length ${\n              json.length\n            }`\n          });\n        }\n        const result = [];\n        for (let i: number = 0; i < decoders.length; i++) {\n          const nth = decoders[i].decode(json[i]);\n          if (nth.ok) {\n            result[i] = nth.result;\n          } else {\n            return Result.err(prependAt(`[${i}]`, nth.error));\n          }\n        }\n        return Result.ok(result);\n      } else {\n        return Result.err({message: expectedGot(`a tuple of length ${decoders.length}`, json)});\n      }\n    });\n  }\n\n  /**\n   * Decoder for json objects where the keys are unknown strings, but the values\n   * should all be of the same type.\n   *\n   * Example:\n   * ```\n   * dict(number()).run({chocolate: 12, vanilla: 10, mint: 37});\n   * // => {ok: true, result: {chocolate: 12, vanilla: 10, mint: 37}}\n   * ```\n   */\n  static dict = <A>(decoder: Decoder<A>): Decoder<Record<string, A>> =>\n    new Decoder(json => {\n      if (isJsonObject(json)) {\n        let obj: Record<string, A> = {};\n        for (const key in json) {\n          if (json.hasOwnProperty(key)) {\n            const r = decoder.decode(json[key]);\n            if (r.ok === true) {\n              obj[key] = r.result;\n            } else {\n              return Result.err(prependAt(`.${key}`, r.error));\n            }\n          }\n        }\n        return Result.ok(obj);\n      } else {\n        return Result.err({message: expectedGot('an object', json)});\n      }\n    });\n\n  /**\n   * Decoder for values that may be `undefined`. This is primarily helpful for\n   * decoding interfaces with optional fields.\n   *\n   * Example:\n   * ```\n   * interface User {\n   *   id: number;\n   *   isOwner?: boolean;\n   * }\n   *\n   * const decoder: Decoder<User> = object({\n   *   id: number(),\n   *   isOwner: optional(boolean())\n   * });\n   * ```\n   */\n  static optional = <A>(decoder: Decoder<A>): Decoder<undefined | A> =>\n    new Decoder<undefined | A>(\n      (json: unknown) => (json === undefined ? Result.ok(undefined) : decoder.decode(json))\n    );\n\n  /**\n   * Decoder that attempts to run each decoder in `decoders` and either succeeds\n   * with the first successful decoder, or fails after all decoders have failed.\n   *\n   * Note that `oneOf` expects the decoders to all have the same return type,\n   * while `union` creates a decoder for the union type of all the input\n   * decoders.\n   *\n   * Examples:\n   * ```\n   * oneOf(string(), number().map(String))\n   * oneOf(constant('start'), constant('stop'), succeed('unknown'))\n   * ```\n   */\n  static oneOf = <A>(...decoders: Decoder<A>[]): Decoder<A> =>\n    new Decoder<A>((json: unknown) => {\n      const errors: Partial<DecoderError>[] = [];\n      for (let i: number = 0; i < decoders.length; i++) {\n        const r = decoders[i].decode(json);\n        if (r.ok === true) {\n          return r;\n        } else {\n          errors[i] = r.error;\n        }\n      }\n      const errorsList = errors\n        .map(error => `at error${error.at || ''}: ${error.message}`)\n        .join('\", \"');\n      return Result.err({\n        message: `expected a value matching one of the decoders, got the errors [\"${errorsList}\"]`\n      });\n    });\n\n  /**\n   * Combines 2-8 decoders of disparate types into a decoder for the union of all\n   * the types.\n   *\n   * If you need more than 8 variants for your union, it's possible to use\n   * `oneOf` in place of `union` as long as you annotate every decoder with the\n   * union type.\n   *\n   * Example:\n   * ```\n   * type C = {a: string} | {b: number};\n   *\n   * const unionDecoder: Decoder<C> = union(object({a: string()}), object({b: number()}));\n   * const oneOfDecoder: Decoder<C> = oneOf(object<C>({a: string()}), object<C>({b: number()}));\n   * ```\n   */\n  static union <A, B>(ad: Decoder<A>, bd: Decoder<B>): Decoder<A | B>; // prettier-ignore\n  static union <A, B, C>(ad: Decoder<A>, bd: Decoder<B>, cd: Decoder<C>): Decoder<A | B | C>; // prettier-ignore\n  static union <A, B, C, D>(ad: Decoder<A>, bd: Decoder<B>, cd: Decoder<C>, dd: Decoder<D>): Decoder<A | B | C | D>; // prettier-ignore\n  static union <A, B, C, D, E>(ad: Decoder<A>, bd: Decoder<B>, cd: Decoder<C>, dd: Decoder<D>, ed: Decoder<E>): Decoder<A | B | C | D | E>; // prettier-ignore\n  static union <A, B, C, D, E, F>(ad: Decoder<A>, bd: Decoder<B>, cd: Decoder<C>, dd: Decoder<D>, ed: Decoder<E>, fd: Decoder<F>): Decoder<A | B | C | D | E | F>; // prettier-ignore\n  static union <A, B, C, D, E, F, G>(ad: Decoder<A>, bd: Decoder<B>, cd: Decoder<C>, dd: Decoder<D>, ed: Decoder<E>, fd: Decoder<F>, gd: Decoder<G>): Decoder<A | B | C | D | E | F | G>; // prettier-ignore\n  static union <A, B, C, D, E, F, G, H>(ad: Decoder<A>, bd: Decoder<B>, cd: Decoder<C>, dd: Decoder<D>, ed: Decoder<E>, fd: Decoder<F>, gd: Decoder<G>, hd: Decoder<H>): Decoder<A | B | C | D | E | F | G | H>; // prettier-ignore\n  static union(ad: Decoder<any>, bd: Decoder<any>, ...decoders: Decoder<any>[]): Decoder<any> {\n    return Decoder.oneOf(ad, bd, ...decoders);\n  }\n\n  /**\n   * Combines 2-8 object decoders into a decoder for the intersection of all the objects.\n   *\n   * Example:\n   * ```\n   * interface Pet {\n   *   name: string;\n   *   maxLegs: number;\n   * }\n   *\n   * interface Cat extends Pet {\n   *   evil: boolean;\n   * }\n   *\n   * const petDecoder: Decoder<Pet> = object({name: string(), maxLegs: number()});\n   * const catDecoder: Decoder<Cat> = intersection(petDecoder, object({evil: boolean()}));\n   * ```\n   */\n  static intersection <A, B>(ad: Decoder<A>, bd: Decoder<B>): Decoder<A & B>; // prettier-ignore\n  static intersection <A, B, C>(ad: Decoder<A>, bd: Decoder<B>, cd: Decoder<C>): Decoder<A & B & C>; // prettier-ignore\n  static intersection <A, B, C, D>(ad: Decoder<A>, bd: Decoder<B>, cd: Decoder<C>, dd: Decoder<D>): Decoder<A & B & C & D>; // prettier-ignore\n  static intersection <A, B, C, D, E>(ad: Decoder<A>, bd: Decoder<B>, cd: Decoder<C>, dd: Decoder<D>, ed: Decoder<E>): Decoder<A & B & C & D & E>; // prettier-ignore\n  static intersection <A, B, C, D, E, F>(ad: Decoder<A>, bd: Decoder<B>, cd: Decoder<C>, dd: Decoder<D>, ed: Decoder<E>, fd: Decoder<F>): Decoder<A & B & C & D & E & F>; // prettier-ignore\n  static intersection <A, B, C, D, E, F, G>(ad: Decoder<A>, bd: Decoder<B>, cd: Decoder<C>, dd: Decoder<D>, ed: Decoder<E>, fd: Decoder<F>, gd: Decoder<G>): Decoder<A & B & C & D & E & F & G>; // prettier-ignore\n  static intersection <A, B, C, D, E, F, G, H>(ad: Decoder<A>, bd: Decoder<B>, cd: Decoder<C>, dd: Decoder<D>, ed: Decoder<E>, fd: Decoder<F>, gd: Decoder<G>, hd: Decoder<H>): Decoder<A & B & C & D & E & F & G & H>; // prettier-ignore\n  static intersection(ad: Decoder<any>, bd: Decoder<any>, ...ds: Decoder<any>[]): Decoder<any> {\n    return new Decoder((json: unknown) =>\n      [ad, bd, ...ds].reduce(\n        (acc: DecodeResult<any>, decoder) => Result.map2(Object.assign, acc, decoder.decode(json)),\n        Result.ok({})\n      )\n    );\n  }\n\n  /**\n   * Decoder that always succeeds with either the decoded value, or a fallback\n   * default value.\n   */\n  static withDefault = <A>(defaultValue: A, decoder: Decoder<A>): Decoder<A> =>\n    new Decoder<A>((json: unknown) =>\n      Result.ok(Result.withDefault(defaultValue, decoder.decode(json)))\n    );\n\n  /**\n   * Decoder that pulls a specific field out of a json structure, instead of\n   * decoding and returning the full structure. The `paths` array describes the\n   * object keys and array indices to traverse, so that values can be pulled out\n   * of a nested structure.\n   *\n   * Example:\n   * ```\n   * const decoder = valueAt(['a', 'b', 0], string());\n   *\n   * decoder.run({a: {b: ['surprise!']}})\n   * // => {ok: true, result: 'surprise!'}\n   *\n   * decoder.run({a: {x: 'cats'}})\n   * // => {ok: false, error: {... at: 'input.a.b[0]' message: 'path does not exist'}}\n   * ```\n   *\n   * Note that the `decoder` is ran on the value found at the last key in the\n   * path, even if the last key is not found. This allows the `optional`\n   * decoder to succeed when appropriate.\n   * ```\n   * const optionalDecoder = valueAt(['a', 'b', 'c'], optional(string()));\n   *\n   * optionalDecoder.run({a: {b: {c: 'surprise!'}}})\n   * // => {ok: true, result: 'surprise!'}\n   *\n   * optionalDecoder.run({a: {b: 'cats'}})\n   * // => {ok: false, error: {... at: 'input.a.b.c' message: 'expected an object, got \"cats\"'}\n   *\n   * optionalDecoder.run({a: {b: {z: 1}}})\n   * // => {ok: true, result: undefined}\n   * ```\n   */\n  static valueAt = <A>(paths: (string | number)[], decoder: Decoder<A>): Decoder<A> =>\n    new Decoder<A>((json: unknown) => {\n      let jsonAtPath: any = json;\n      for (let i: number = 0; i < paths.length; i++) {\n        if (jsonAtPath === undefined) {\n          return Result.err({\n            at: printPath(paths.slice(0, i + 1)),\n            message: 'path does not exist'\n          });\n        } else if (typeof paths[i] === 'string' && !isJsonObject(jsonAtPath)) {\n          return Result.err({\n            at: printPath(paths.slice(0, i + 1)),\n            message: expectedGot('an object', jsonAtPath)\n          });\n        } else if (typeof paths[i] === 'number' && !isJsonArray(jsonAtPath)) {\n          return Result.err({\n            at: printPath(paths.slice(0, i + 1)),\n            message: expectedGot('an array', jsonAtPath)\n          });\n        } else {\n          jsonAtPath = jsonAtPath[paths[i]];\n        }\n      }\n      return Result.mapError(\n        error =>\n          jsonAtPath === undefined\n            ? {at: printPath(paths), message: 'path does not exist'}\n            : prependAt(printPath(paths), error),\n        decoder.decode(jsonAtPath)\n      );\n    });\n\n  /**\n   * Decoder that ignores the input json and always succeeds with `fixedValue`.\n   */\n  static succeed = <A>(fixedValue: A): Decoder<A> =>\n    new Decoder<A>((json: unknown) => Result.ok(fixedValue));\n\n  /**\n   * Decoder that ignores the input json and always fails with `errorMessage`.\n   */\n  static fail = <A>(errorMessage: string): Decoder<A> =>\n    new Decoder<A>((json: unknown) => Result.err({message: errorMessage}));\n\n  /**\n   * Decoder that allows for validating recursive data structures. Unlike with\n   * functions, decoders assigned to variables can't reference themselves\n   * before they are fully defined. We can avoid prematurely referencing the\n   * decoder by wrapping it in a function that won't be called until use, at\n   * which point the decoder has been defined.\n   *\n   * Example:\n   * ```\n   * interface Comment {\n   *   msg: string;\n   *   replies: Comment[];\n   * }\n   *\n   * const decoder: Decoder<Comment> = object({\n   *   msg: string(),\n   *   replies: lazy(() => array(decoder))\n   * });\n   * ```\n   */\n  static lazy = <A>(mkDecoder: () => Decoder<A>): Decoder<A> =>\n    new Decoder((json: unknown) => mkDecoder().decode(json));\n\n  /**\n   * Run the decoder and return a `Result` with either the decoded value or a\n   * `DecoderError` containing the json input, the location of the error, and\n   * the error message.\n   *\n   * Examples:\n   * ```\n   * number().run(12)\n   * // => {ok: true, result: 12}\n   *\n   * string().run(9001)\n   * // =>\n   * // {\n   * //   ok: false,\n   * //   error: {\n   * //     kind: 'DecoderError',\n   * //     input: 9001,\n   * //     at: 'input',\n   * //     message: 'expected a string, got 9001'\n   * //   }\n   * // }\n   * ```\n   */\n  run = (json: unknown): RunResult<A> =>\n    Result.mapError(\n      error => ({\n        kind: 'DecoderError' as 'DecoderError',\n        input: json,\n        at: 'input' + (error.at || ''),\n        message: error.message || ''\n      }),\n      this.decode(json)\n    );\n\n  /**\n   * Run the decoder as a `Promise`.\n   */\n  runPromise = (json: unknown): Promise<A> => Result.asPromise(this.run(json));\n\n  /**\n   * Run the decoder and return the value on success, or throw an exception\n   * with a formatted error string.\n   */\n  runWithException = (json: unknown): A => Result.withException(this.run(json));\n\n  /**\n   * Construct a new decoder that applies a transformation to the decoded\n   * result. If the decoder succeeds then `f` will be applied to the value. If\n   * it fails the error will propagated through.\n   *\n   * Example:\n   * ```\n   * number().map(x => x * 5).run(10)\n   * // => {ok: true, result: 50}\n   * ```\n   */\n  map = <B>(f: (value: A) => B): Decoder<B> =>\n    new Decoder<B>((json: unknown) => Result.map(f, this.decode(json)));\n\n  /**\n   * Chain together a sequence of decoders. The first decoder will run, and\n   * then the function will determine what decoder to run second. If the result\n   * of the first decoder succeeds then `f` will be applied to the decoded\n   * value. If it fails the error will propagate through.\n   *\n   * This is a very powerful method -- it can act as both the `map` and `where`\n   * methods, can improve error messages for edge cases, and can be used to\n   * make a decoder for custom types.\n   *\n   * Example of adding an error message:\n   * ```\n   * const versionDecoder = valueAt(['version'], number());\n   * const infoDecoder3 = object({a: boolean()});\n   *\n   * const decoder = versionDecoder.andThen(version => {\n   *   switch (version) {\n   *     case 3:\n   *       return infoDecoder3;\n   *     default:\n   *       return fail(`Unable to decode info, version ${version} is not supported.`);\n   *   }\n   * });\n   *\n   * decoder.run({version: 3, a: true})\n   * // => {ok: true, result: {a: true}}\n   *\n   * decoder.run({version: 5, x: 'abc'})\n   * // =>\n   * // {\n   * //   ok: false,\n   * //   error: {... message: 'Unable to decode info, version 5 is not supported.'}\n   * // }\n   * ```\n   *\n   * Example of decoding a custom type:\n   * ```\n   * // nominal type for arrays with a length of at least one\n   * type NonEmptyArray<T> = T[] & { __nonEmptyArrayBrand__: void };\n   *\n   * const nonEmptyArrayDecoder = <T>(values: Decoder<T>): Decoder<NonEmptyArray<T>> =>\n   *   array(values).andThen(arr =>\n   *     arr.length > 0\n   *       ? succeed(createNonEmptyArray(arr))\n   *       : fail(`expected a non-empty array, got an empty array`)\n   *   );\n   * ```\n   */\n  andThen = <B>(f: (value: A) => Decoder<B>): Decoder<B> =>\n    new Decoder<B>((json: unknown) =>\n      Result.andThen(value => f(value).decode(json), this.decode(json))\n    );\n\n  /**\n   * Add constraints to a decoder _without_ changing the resulting type. The\n   * `test` argument is a predicate function which returns true for valid\n   * inputs. When `test` fails on an input, the decoder fails with the given\n   * `errorMessage`.\n   *\n   * ```\n   * const chars = (length: number): Decoder<string> =>\n   *   string().where(\n   *     (s: string) => s.length === length,\n   *     `expected a string of length ${length}`\n   *   );\n   *\n   * chars(5).run('12345')\n   * // => {ok: true, result: '12345'}\n   *\n   * chars(2).run('HELLO')\n   * // => {ok: false, error: {... message: 'expected a string of length 2'}}\n   *\n   * chars(12).run(true)\n   * // => {ok: false, error: {... message: 'expected a string, got a boolean'}}\n   * ```\n   */\n  where = (test: (value: A) => boolean, errorMessage: string): Decoder<A> =>\n    this.andThen((value: A) => (test(value) ? Decoder.succeed(value) : Decoder.fail(errorMessage)));\n}\n","import {Decoder} from './decoder';\n\n/* tslint:disable:variable-name */\n\n/** See `Decoder.string` */\nexport const string = Decoder.string;\n\n/** See `Decoder.number` */\nexport const number = Decoder.number;\n\n/** See `Decoder.boolean` */\nexport const boolean = Decoder.boolean;\n\n/** See `Decoder.anyJson` */\nexport const anyJson = Decoder.anyJson;\n\n/** See `Decoder.unknownJson` */\nexport const unknownJson: () => Decoder<unknown> = Decoder.unknownJson;\n\n/** See `Decoder.constant` */\nexport const constant = Decoder.constant;\n\n/** See `Decoder.object` */\nexport const object = Decoder.object;\n\n/** See `Decoder.array` */\nexport const array = Decoder.array;\n\n/** See `Decoder.tuple` */\nexport const tuple = Decoder.tuple;\n\n/** See `Decoder.dict` */\nexport const dict = Decoder.dict;\n\n/** See `Decoder.optional` */\nexport const optional = Decoder.optional;\n\n/** See `Decoder.oneOf` */\nexport const oneOf = Decoder.oneOf;\n\n/** See `Decoder.union` */\nexport const union = Decoder.union;\n\n/** See `Decoder.intersection` */\nexport const intersection = Decoder.intersection;\n\n/** See `Decoder.withDefault` */\nexport const withDefault = Decoder.withDefault;\n\n/** See `Decoder.valueAt` */\nexport const valueAt = Decoder.valueAt;\n\n/** See `Decoder.succeed` */\nexport const succeed = Decoder.succeed;\n\n/** See `Decoder.fail` */\nexport const fail = Decoder.fail;\n\n/** See `Decoder.lazy` */\nexport const lazy = Decoder.lazy;\n"]},"metadata":{},"sourceType":"module"}