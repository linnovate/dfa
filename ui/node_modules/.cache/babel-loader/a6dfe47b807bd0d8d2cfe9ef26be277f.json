{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assert = void 0; // Copyright (c) 2021 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar types_1 = require(\"@daml/types\");\n\nvar jtv = __importStar(require(\"@mojotech/json-type-validation\"));\n\nvar cross_fetch_1 = __importDefault(require(\"cross-fetch\"));\n\nvar events_1 = require(\"events\");\n\nvar isomorphic_ws_1 = __importDefault(require(\"isomorphic-ws\"));\n\nvar lodash_1 = __importDefault(require(\"lodash\"));\n\nvar partyInfoDecoder = jtv.object({\n  identifier: jtv.string(),\n  displayName: jtv.optional(jtv.string()),\n  isLocal: jtv.boolean()\n});\n\nvar decode = function (decoder, data) {\n  return jtv.Result.withException(decoder.run(data));\n};\n/**\n * Decoder for a [[CreateEvent]].\n */\n\n\nvar decodeCreateEvent = function (template) {\n  return jtv.object({\n    templateId: jtv.constant(template.templateId),\n    contractId: types_1.ContractId(template).decoder,\n    signatories: types_1.List(types_1.Party).decoder,\n    observers: types_1.List(types_1.Party).decoder,\n    agreementText: types_1.Text.decoder,\n    key: template.keyDecoder,\n    payload: template.decoder\n  });\n};\n/**\n * Decoder for a [[CreateEvent]] of unknown contract template.\n */\n\n\nvar decodeCreateEventUnknown = jtv.valueAt(['templateId'], jtv.string()).andThen(function (templateId) {\n  return decodeCreateEvent(types_1.lookupTemplate(templateId));\n});\n/**\n * Decoder for an [[ArchiveEvent]].\n */\n\nvar decodeArchiveEvent = function (template) {\n  return jtv.object({\n    templateId: jtv.constant(template.templateId),\n    contractId: types_1.ContractId(template).decoder\n  });\n};\n/**\n * Decoder for an [[ArchiveEvent]] of unknown contract template.\n */\n\n\nvar decodeArchiveEventUnknown = jtv.valueAt(['templateId'], jtv.string()).andThen(function (templateId) {\n  return decodeArchiveEvent(types_1.lookupTemplate(templateId));\n});\n/**\n * Decoder for an [[Event]].\n */\n\nvar decodeEvent = function (template) {\n  return jtv.oneOf(jtv.object({\n    created: decodeCreateEvent(template)\n  }), jtv.object({\n    archived: decodeArchiveEvent(template)\n  }));\n};\n/**\n * Decoder for an [[Event]] with unknown contract template.\n */\n\n\nvar decodeEventUnknown = jtv.oneOf(jtv.object({\n  created: decodeCreateEventUnknown\n}), jtv.object({\n  archived: decodeArchiveEventUnknown\n}));\n/**\n * @internal\n */\n\nfunction decodeArchiveResponse(template, archiveMethod, archiveCommand) {\n  return __awaiter(this, void 0, void 0, function () {\n    var _a, _b, events;\n\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , archiveCommand()];\n\n        case 1:\n          _a = _c.sent(), _b = _a[0], events = _a[1];\n\n          if (events.length === 1 && 'archived' in events[0] && events[0].archived.templateId === template.templateId) {\n            return [2\n            /*return*/\n            , events[0].archived];\n          } else {\n            throw Error(\"Ledger.\" + archiveMethod + \" is expected to cause one archive event for template \" + template.templateId + \"       but caused \" + JSON.stringify(events) + \".\");\n          }\n\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n/**\n * @internal\n */\n\n\nfunction isRecordWith(field, x) {\n  return typeof x === 'object' && x !== null && field in x;\n}\n/** @internal\n * exported for testing only\n */\n\n\nfunction assert(b, m) {\n  if (!b) {\n    throw m;\n  }\n}\n\nexports.assert = assert; // TODO(MH): Support comparison queries.\n\n/** @internal\n *\n * Official documentation (docs/source/json-api/search-query-language.rst)\n * currently explicitly forbids the use of lists, textmaps and genmaps in\n * queries. As long as that restriction stays, there is no need for any kind of\n * encoding here.\n */\n\nfunction encodeQuery(template, query) {\n  // I could not get the \"unused\" warning silenced, but this seems to count as \"used\"\n  [template];\n  return query;\n}\n/**\n * @internal\n */\n\n\nvar decodeLedgerResponse = jtv.object({\n  status: jtv.number(),\n  result: jtv.unknownJson(),\n  warnings: jtv.optional(jtv.unknownJson())\n});\n/**\n * @internal\n */\n\nvar decodeLedgerError = jtv.object({\n  status: jtv.number(),\n  errors: jtv.array(jtv.string()),\n  warnings: jtv.optional(jtv.unknownJson())\n});\n/**\n * An object of type `Ledger` represents a handle to a Daml ledger.\n */\n\nvar Ledger =\n/** @class */\nfunction () {\n  /**\n   * Construct a new `Ledger` object. See [[LedgerOptions]] for the constructor arguments.\n   */\n  function Ledger(_a) {\n    var token = _a.token,\n        httpBaseUrl = _a.httpBaseUrl,\n        wsBaseUrl = _a.wsBaseUrl,\n        _b = _a.reconnectThreshold,\n        reconnectThreshold = _b === void 0 ? 30000 : _b;\n\n    if (!httpBaseUrl) {\n      httpBaseUrl = window.location.protocol + \"//\" + window.location.host + \"/\";\n    }\n\n    if (!(httpBaseUrl.startsWith('http://') || httpBaseUrl.startsWith('https://'))) {\n      throw Error(\"Ledger: httpBaseUrl must start with 'http://' or 'https://'. (\" + httpBaseUrl + \")\");\n    }\n\n    if (!httpBaseUrl.endsWith('/')) {\n      throw Error(\"Ledger: httpBaseUrl must end with '/'. (\" + httpBaseUrl + \")\");\n    }\n\n    if (!wsBaseUrl) {\n      wsBaseUrl = 'ws' + httpBaseUrl.slice(4);\n    }\n\n    if (!(wsBaseUrl.startsWith('ws://') || wsBaseUrl.startsWith('wss://'))) {\n      throw Error(\"Ledger: wsBaseUrl must start with 'ws://' or 'wss://'. (\" + wsBaseUrl + \")\");\n    }\n\n    if (!wsBaseUrl.endsWith('/')) {\n      throw Error(\"Ledger: wsBaseUrl must end with '/'. (\" + wsBaseUrl + \")\");\n    }\n\n    this.token = token;\n    this.httpBaseUrl = httpBaseUrl;\n    this.wsBaseUrl = wsBaseUrl;\n    this.reconnectThreshold = reconnectThreshold;\n  }\n  /**\n   * @internal\n   */\n\n\n  Ledger.prototype.auth = function () {\n    return {\n      'Authorization': 'Bearer ' + this.token\n    };\n  };\n  /**\n   * @internal\n   */\n\n\n  Ledger.prototype.throwOnError = function (r) {\n    return __awaiter(this, void 0, void 0, function () {\n      var json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!!r.ok) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , r.json()];\n\n          case 1:\n            json = _a.sent();\n            console.log(json);\n            throw decode(decodeLedgerError, json);\n\n          case 2:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * @internal\n   *\n   * Internal function to submit a command to the JSON API.\n   */\n\n\n  Ledger.prototype.submit = function (endpoint, payload, method) {\n    if (method === void 0) {\n      method = 'post';\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var httpResponse, json, ledgerResponse;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , cross_fetch_1.default(this.httpBaseUrl + endpoint, {\n              body: JSON.stringify(payload),\n              headers: __assign(__assign({}, this.auth()), {\n                'Content-type': 'application/json'\n              }),\n              method: method\n            })];\n\n          case 1:\n            httpResponse = _a.sent();\n            return [4\n            /*yield*/\n            , this.throwOnError(httpResponse)];\n\n          case 2:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , httpResponse.json()];\n\n          case 3:\n            json = _a.sent();\n            ledgerResponse = jtv.Result.withException(decodeLedgerResponse.run(json));\n\n            if (ledgerResponse.warnings) {\n              console.warn(ledgerResponse.warnings);\n            }\n\n            return [2\n            /*return*/\n            , ledgerResponse.result];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieve contracts for a given template.\n   *\n   * When no `query` argument is given, all contracts visible to the submitting party are returned.\n   * When a `query` argument is given, only those contracts matching the query are returned. See\n   * https://docs.daml.com/json-api/search-query-language.html for a description of the query\n   * language.\n   *\n   * @param template The contract template of the contracts to be matched against.\n   * @param query The contract query for the contracts to be matched against.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   *\n   */\n\n\n  Ledger.prototype.query = function (template, query) {\n    return __awaiter(this, void 0, void 0, function () {\n      var payload, json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            payload = {\n              templateIds: [template.templateId],\n              query: encodeQuery(template, query)\n            };\n            return [4\n            /*yield*/\n            , this.submit('v1/query', payload)];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , jtv.Result.withException(jtv.array(decodeCreateEvent(template)).run(json))];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a contract identified by its contract ID.\n   *\n   * @param template The template of the contract to be fetched.\n   * @param contractId The contract id of the contract to be fetched.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   *\n   */\n\n\n  Ledger.prototype.fetch = function (template, contractId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var payload, json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            payload = {\n              templateId: template.templateId,\n              contractId: types_1.ContractId(template).encode(contractId)\n            };\n            return [4\n            /*yield*/\n            , this.submit('v1/fetch', payload)];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , jtv.Result.withException(jtv.oneOf(jtv.constant(null), decodeCreateEvent(template)).run(json))];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a contract identified by its contract key.\n   *\n   * Same as [[fetch]], but the contract to be fetched is identified by its contract key instead of\n   * its contract id.\n   *\n   * @param template The template of the contract to be fetched.\n   * @param key The contract key of the contract to be fetched.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   */\n\n\n  Ledger.prototype.fetchByKey = function (template, key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var payload, json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (key === undefined) {\n              throw Error(\"Cannot lookup by key on template \" + template.templateId + \" because it does not define a key.\");\n            }\n\n            payload = {\n              templateId: template.templateId,\n              key: template.keyEncode(key)\n            };\n            return [4\n            /*yield*/\n            , this.submit('v1/fetch', payload)];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , jtv.Result.withException(jtv.oneOf(jtv.constant(null), decodeCreateEvent(template)).run(json))];\n        }\n      });\n    });\n  };\n  /**\n   * Create a contract for a given template.\n   *\n   * @param template The template of the contract to be created.\n   * @param payload The template arguments for the contract to be created.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   *\n   */\n\n\n  Ledger.prototype.create = function (template, payload) {\n    return __awaiter(this, void 0, void 0, function () {\n      var command, json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            command = {\n              templateId: template.templateId,\n              payload: template.encode(payload)\n            };\n            return [4\n            /*yield*/\n            , this.submit('v1/create', command)];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , jtv.Result.withException(decodeCreateEvent(template).run(json))];\n        }\n      });\n    });\n  };\n  /**\n   * Exercise a choice on a contract identified by its contract ID.\n   *\n   * @param choice The choice to exercise.\n   * @param contractId The contract id of the contract to exercise.\n   * @param argument The choice arguments.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam C The type of the contract choice.\n   * @typeparam R The return type of the choice.\n   *\n   * @returns The return value of the choice together with a list of\n   * [[event]]'s that were created as a result of exercising the choice.\n   */\n\n\n  Ledger.prototype.exercise = function (choice, contractId, argument) {\n    return __awaiter(this, void 0, void 0, function () {\n      var payload, json, responseDecoder, _a, exerciseResult, events;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            payload = {\n              templateId: choice.template().templateId,\n              contractId: types_1.ContractId(choice.template()).encode(contractId),\n              choice: choice.choiceName,\n              argument: choice.argumentEncode(argument)\n            };\n            return [4\n            /*yield*/\n            , this.submit('v1/exercise', payload)];\n\n          case 1:\n            json = _b.sent();\n            responseDecoder = jtv.object({\n              exerciseResult: choice.resultDecoder,\n              events: jtv.array(decodeEventUnknown)\n            });\n            _a = jtv.Result.withException(responseDecoder.run(json)), exerciseResult = _a.exerciseResult, events = _a.events;\n            return [2\n            /*return*/\n            , [exerciseResult, events]];\n        }\n      });\n    });\n  };\n  /**\n   * Exercse a choice on a newly-created contract, in a single transaction.\n   *\n   * @param choice The choice to exercise.\n   * @param init The template arguments for the newly-created contract.\n   * @param argument The choice arguments.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam C The type of the contract choice.\n   * @typeparam R The return type of the choice.\n   *\n   * @returns The return value of the choice together with a list of\n   * [[event]]'s that includes the creation event for the created contract as\n   * well as all the events that were created as a result of exercising the\n   * choice, including the archive event for the created contract if the choice\n   * is consuming (or otherwise archives it as part of its execution).\n   *\n   */\n\n\n  Ledger.prototype.createAndExercise = function (choice, payload, argument) {\n    return __awaiter(this, void 0, void 0, function () {\n      var command, json, responseDecoder, _a, exerciseResult, events;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            command = {\n              templateId: choice.template().templateId,\n              payload: choice.template().encode(payload),\n              choice: choice.choiceName,\n              argument: choice.argumentEncode(argument)\n            };\n            return [4\n            /*yield*/\n            , this.submit('v1/create-and-exercise', command)];\n\n          case 1:\n            json = _b.sent();\n            responseDecoder = jtv.object({\n              exerciseResult: choice.resultDecoder,\n              events: jtv.array(decodeEventUnknown)\n            });\n            _a = jtv.Result.withException(responseDecoder.run(json)), exerciseResult = _a.exerciseResult, events = _a.events;\n            return [2\n            /*return*/\n            , [exerciseResult, events]];\n        }\n      });\n    });\n  };\n  /**\n   * Exercise a choice on a contract identified by its contract key.\n   *\n   * Same as [[exercise]], but the contract is identified by its contract key instead of its\n   * contract id.\n   *\n   * @param choice The choice to exercise.\n   * @param contractId The contract id of the contract to exercise.\n   * @param argument The choice arguments.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam C The type of the contract choice.\n   * @typeparam R The return type of the choice.\n   * @typeparam K The type of the contract key.\n   *\n   * @returns The return value of the choice together with a list of [[event]]'s that where created\n   * as a result of exercising the choice.\n   */\n\n\n  Ledger.prototype.exerciseByKey = function (choice, key, argument) {\n    return __awaiter(this, void 0, void 0, function () {\n      var payload, json, responseDecoder, _a, exerciseResult, events;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (key === undefined) {\n              throw Error(\"Cannot exercise by key on template \" + choice.template().templateId + \" because it does not define a key.\");\n            }\n\n            payload = {\n              templateId: choice.template().templateId,\n              key: choice.template().keyEncode(key),\n              choice: choice.choiceName,\n              argument: choice.argumentEncode(argument)\n            };\n            return [4\n            /*yield*/\n            , this.submit('v1/exercise', payload)];\n\n          case 1:\n            json = _b.sent();\n            responseDecoder = jtv.object({\n              exerciseResult: choice.resultDecoder,\n              events: jtv.array(decodeEventUnknown)\n            });\n            _a = jtv.Result.withException(responseDecoder.run(json)), exerciseResult = _a.exerciseResult, events = _a.events;\n            return [2\n            /*return*/\n            , [exerciseResult, events]];\n        }\n      });\n    });\n  };\n  /**\n   * Archive a contract identified by its contract ID.\n   *\n   * @param template The template of the contract to archive.\n   * @param contractId The contract id of the contract to archive.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   *\n   */\n\n\n  Ledger.prototype.archive = function (template, contractId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , decodeArchiveResponse(template, 'archive', function () {\n          return _this.exercise(template.Archive, contractId, {});\n        })];\n      });\n    });\n  };\n  /**\n   * Archive a contract identified by its contract key.\n   * Same as [[archive]], but the contract to be archived is identified by its contract key.\n   *\n   * @param template The template of the contract to be archived.\n   * @param key The contract key of the contract to be archived.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   *\n   */\n\n\n  Ledger.prototype.archiveByKey = function (template, key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , decodeArchiveResponse(template, 'archiveByKey', function () {\n          return _this.exerciseByKey(template.Archive, key, {});\n        })];\n      });\n    });\n  };\n  /**\n   * @internal\n   *\n   * Internal command to submit a request to a streaming endpoint of the\n   * JSON API. Returns a stream consisting of accumulated state together with\n   * the events that produced the latest state change. The `change` function\n   * must be an operation of the monoid `Event<T, K, I>[]` on the set `State`,\n   * i.e., for all `s: State` and `x, y: Event<T, K, I>[]` we\n   * must have the structural equalities\n   * ```\n   * change(s, []) == s\n   * change(s, x.concat(y)) == change(change(s, x), y)\n   * ```\n   * Also, `change` must never change its arguments.\n   */\n\n\n  Ledger.prototype.streamSubmit = function (callerName, template, endpoint, request, reconnectRequest, init, change) {\n    var _this = this;\n\n    var protocols = ['jwt.token.' + this.token, 'daml.ws.auth'];\n    var ws = new isomorphic_ws_1.default(this.wsBaseUrl + endpoint, protocols);\n    var isLiveSince = undefined;\n    var lastOffset = undefined;\n    var state = init;\n    var isReconnecting = false;\n    var streamClosed = false;\n    var emitter = new events_1.EventEmitter();\n\n    var onWsOpen = function () {\n      if (isReconnecting) {\n        // the JSON API server can't handle null offsets, even though it sends them out under\n        // special conditions when there are no transactions yet. Not sending the `offset` message\n        // will start the stream from the very beginning of the transaction log.\n        if (lastOffset !== null) ws.send(JSON.stringify({\n          'offset': lastOffset\n        }));\n        ws.send(JSON.stringify(reconnectRequest()));\n      } else {\n        ws.send(JSON.stringify(request));\n      }\n    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    var onWsMessage = function (event) {\n      var json = JSON.parse(event.data.toString());\n\n      if (isRecordWith('events', json)) {\n        var events = jtv.Result.withException(jtv.array(decodeEvent(template)).run(json.events));\n\n        if (events.length > 0) {\n          state = change(state, events);\n          emitter.emit('change', state, events);\n        }\n\n        if (isRecordWith('offset', json)) {\n          lastOffset = jtv.Result.withException(jtv.oneOf(jtv.constant(null), jtv.string()).run(json.offset));\n\n          if (isLiveSince === undefined) {\n            isLiveSince = Date.now();\n            emitter.emit('live', state);\n          }\n        }\n      } else if (isRecordWith('warnings', json)) {\n        console.warn(\"Ledger.\" + callerName + \" warnings\", json);\n      } else if (isRecordWith('errors', json)) {\n        console.error(\"Ledger.\" + callerName + \" errors\", json);\n      } else {\n        console.error(\"Ledger.\" + callerName + \" unknown message\", json);\n      }\n    };\n\n    var closeStream = function (status) {\n      streamClosed = true;\n      emitter.emit('close', status);\n      emitter.removeAllListeners();\n    };\n\n    var onWsClose = function () {\n      if (streamClosed === false) {\n        var now = new Date().getTime(); // we want to try and keep the stream open, so we try to reconnect\n        // the underlying ws\n\n        if (lastOffset !== undefined && isLiveSince !== undefined && now - isLiveSince >= _this.reconnectThreshold) {\n          isLiveSince = undefined;\n          isReconnecting = true;\n          ws = new isomorphic_ws_1.default(_this.wsBaseUrl + endpoint, protocols);\n          ws.addEventListener('open', onWsOpen);\n          ws.addEventListener('message', onWsMessage);\n          ws.addEventListener('close', onWsClose);\n        } else {\n          // ws has closed too quickly / never managed to connect: we give up\n          closeStream({\n            code: 4001,\n            reason: 'ws connection failed'\n          });\n        }\n      } // no else: if the stream is closed we don't need to keep a ws\n\n    };\n\n    ws.addEventListener('open', onWsOpen);\n    ws.addEventListener('message', onWsMessage); // NOTE(MH): We ignore the 'error' event since it is always followed by a\n    // 'close' event, which we need to handle anyway.\n\n    ws.addEventListener('close', onWsClose); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    var on = function (type, listener) {\n      if (streamClosed === false) {\n        void emitter.on(type, listener);\n      } else {\n        console.error(\"Trying to add a listener to a closed stream.\");\n      }\n    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    var off = function (type, listener) {\n      if (streamClosed === false) {\n        void emitter.off(type, listener);\n      } else {\n        console.error(\"Trying to remove a listener from a closed stream.\");\n      }\n    };\n\n    var close = function () {\n      // Note: ws.close will trigger the onClose handlers of the WebSocket\n      // (here onWsClose), but they execute as a separate event after the\n      // current event in the JS event loop, i.e. in particular after the call\n      // to closeStream and thus, in this case, the onWsClose handler will see\n      // streamClosed as true.\n      ws.close();\n      closeStream({\n        code: 4000,\n        reason: \"called .close()\"\n      });\n    };\n\n    return {\n      on: on,\n      off: off,\n      close: close\n    };\n  };\n  /**\n   * Retrieve a consolidated stream of events for a given template and query.\n   *\n   * The accumulated state is the current set of active contracts matching the query. When no\n   * `query` argument is given, all events visible to the submitting party are returned. When a\n   * `query` argument is given, only those create events matching the query are returned. See\n   * https://docs.daml.com/json-api/search-query-language.html for a description of the query\n   * language.\n   *\n   * @deprecated Prefer `streamQueries`.\n   *\n   * @param template The contract template to match contracts against.\n   * @param query The query to match contracts agains.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   *\n   */\n\n\n  Ledger.prototype.streamQuery = function (template, query) {\n    if (query === undefined) {\n      return this.streamQueryCommon(template, [], \"streamQuery\");\n    } else {\n      return this.streamQueryCommon(template, [query], \"streamQuery\");\n    }\n  };\n  /**\n   * @internal\n   *\n   */\n\n\n  Ledger.prototype.streamQueryCommon = function (template, queries, name) {\n    var request = queries.length == 0 ? [{\n      templateIds: [template.templateId]\n    }] : queries.map(function (q) {\n      return {\n        templateIds: [template.templateId],\n        query: encodeQuery(template, q)\n      };\n    });\n\n    var reconnectRequest = function () {\n      return request;\n    };\n\n    var change = function (contracts, events) {\n      var archiveEvents = new Set();\n      var createEvents = [];\n\n      for (var _i = 0, events_2 = events; _i < events_2.length; _i++) {\n        var event_1 = events_2[_i];\n\n        if ('created' in event_1) {\n          createEvents.push(event_1.created);\n        } else {\n          // i.e. 'archived' in event\n          archiveEvents.add(event_1.archived.contractId);\n        }\n      }\n\n      return contracts.concat(createEvents).filter(function (contract) {\n        return !archiveEvents.has(contract.contractId);\n      });\n    };\n\n    return this.streamSubmit(name, template, 'v1/stream/query', request, reconnectRequest, [], change);\n  };\n  /**\n   * Retrieve a consolidated stream of events for a given template and queries.\n   *\n   * If the given list is empty, the accumulated state is the set of all active\n   * contracts for the given template. Otherwise, the accumulated state is the\n   * set of all contracts that match at least one of the given queries.\n   *\n   * See https://docs.daml.com/json-api/search-query-language.html for a\n   * description of the query language.\n   *\n   * @param template The contract template to match contracts against.\n   * @param query A query to match contracts against.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   */\n\n\n  Ledger.prototype.streamQueries = function (template, queries) {\n    return this.streamQueryCommon(template, queries, \"streamQueries\");\n  };\n  /**\n   * Retrieve a consolidated stream of events for a given template and contract key.\n   *\n   * The accumulated state is either the current active contract for the given\n   * key, or null if there is no active contract for the given key.\n   *\n   * @deprecated Prefer `streamFetchByKeys`.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   *\n   */\n\n\n  Ledger.prototype.streamFetchByKey = function (template, key) {\n    // Note: this implementation is deliberately not unified with that of\n    // `streamFetchByKeys`, because doing so would add the requirement that the\n    // given key be in output format, whereas existing implementation supports\n    // input format.\n    var lastContractId = null;\n    var request = [{\n      templateId: template.templateId,\n      key: template.keyEncode(key)\n    }];\n\n    var reconnectRequest = function () {\n      return [__assign(__assign({}, request[0]), {\n        'contractIdAtOffset': lastContractId && types_1.ContractId(template).encode(lastContractId)\n      })];\n    };\n\n    var change = function (contract, events) {\n      for (var _i = 0, events_3 = events; _i < events_3.length; _i++) {\n        var event_2 = events_3[_i];\n\n        if ('created' in event_2) {\n          contract = event_2.created;\n        } else {\n          // i.e. 'archived' event\n          if (contract && contract.contractId === event_2.archived.contractId) {\n            contract = null;\n          }\n        }\n      }\n\n      lastContractId = contract ? contract.contractId : null;\n      return contract;\n    };\n\n    return this.streamSubmit(\"streamFetchByKey\", template, 'v1/stream/fetch', request, reconnectRequest, null, change);\n  };\n  /**\n   * @internal\n   *\n   * Returns the same API as [[streamSubmit]] but does not, in fact, establish\n   * any socket connection. Instead, this is a stream that always has the given\n   * value as its accumulated state.\n   */\n\n\n  Ledger.prototype.constantStream = function (value) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function on(type, listener) {\n      if (type === 'live') {\n        listener(value);\n      }\n\n      if (type === 'change') {\n        listener(value, []);\n      }\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function\n\n\n    function off(_t, _l) {} // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n    return {\n      on: on,\n      off: off,\n      close: function () {}\n    };\n  };\n  /**\n   * Retrieve a consolidated stream of events for a list of keys and a single\n   * template.\n   *\n   * The accumulated state is an array of the same length as the given list of\n   * keys, with positional correspondence. Each element in the array represents\n   * the current contract for the given key, or is explicitly null if there is\n   * currently no active contract matching that key.\n   *\n   * Note: the given `key` objects will be compared for (deep) equality with\n   * the values returned by the API. As such, they have to be given in the\n   * \"output\" format of the API, including the values of\n   * `encodeDecimalAsString` and `encodeInt64AsString`. See [the JSON API docs\n   * for details](https://docs.daml.com/json-api/lf-value-specification.html).\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   */\n\n\n  Ledger.prototype.streamFetchByKeys = function (template, keys) {\n    // We support zero-length key so clients can more easily manage a dynamic\n    // list, without having to special-case 0-length on their side.\n    if (keys.length == 0) {\n      return this.constantStream([]);\n    }\n\n    var lastContractIds = Array(keys.length).fill(null);\n    var keysCopy = lodash_1.default.cloneDeep(keys);\n    var initState = Array(keys.length).fill(null);\n    var request = keys.map(function (k) {\n      return {\n        templateId: template.templateId,\n        key: template.keyEncode(k)\n      };\n    });\n\n    var reconnectRequest = function () {\n      return request.map(function (r, idx) {\n        var lastId = lastContractIds[idx];\n        return __assign(__assign({}, r), {\n          'contractIdAtOffset': lastId && types_1.ContractId(template).encode(lastId)\n        });\n      });\n    };\n\n    var change = function (state, events) {\n      var newState = Array.from(state);\n\n      var _loop_1 = function (event_3) {\n        if ('created' in event_3) {\n          var k_1 = event_3.created.key;\n          keysCopy.forEach(function (requestKey, idx) {\n            if (lodash_1.default.isEqual(requestKey, k_1)) {\n              newState[idx] = event_3.created;\n            }\n          });\n        } else {\n          // i.e. 'archived' in event\n          var id_1 = event_3.archived.contractId;\n          newState.forEach(function (contract, idx) {\n            if (contract && contract.contractId === id_1) {\n              newState[idx] = null;\n            }\n          });\n        }\n      };\n\n      for (var _i = 0, events_4 = events; _i < events_4.length; _i++) {\n        var event_3 = events_4[_i];\n\n        _loop_1(event_3);\n      }\n\n      newState.forEach(function (c, idx) {\n        lastContractIds[idx] = c ? c.contractId : null;\n      });\n      return newState;\n    };\n\n    return this.streamSubmit(\"streamFetchByKeys\", template, 'v1/stream/fetch', request, reconnectRequest, initState, change);\n  };\n  /**\n   * Fetch parties by identifier.\n   *\n   * @param parties An array of Party identifiers.\n   *\n   * @returns An array of the same length, where each element corresponds to\n   * the same-index element of the given parties, ans is either a PartyInfo\n   * object if the party exists or null if it does not.\n   *\n   */\n\n\n  Ledger.prototype.getParties = function (parties) {\n    return __awaiter(this, void 0, void 0, function () {\n      var json, resp, mapping, _i, resp_1, p, ret, idx;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (parties.length === 0) {\n              return [2\n              /*return*/\n              , []];\n            }\n\n            return [4\n            /*yield*/\n            , this.submit('v1/parties', parties)];\n\n          case 1:\n            json = _a.sent();\n            resp = decode(jtv.array(partyInfoDecoder), json);\n            mapping = {};\n\n            for (_i = 0, resp_1 = resp; _i < resp_1.length; _i++) {\n              p = resp_1[_i];\n              mapping[p.identifier] = p;\n            }\n\n            ret = Array(parties.length).fill(null);\n\n            for (idx = 0; idx < parties.length; idx++) {\n              ret[idx] = mapping[parties[idx]] || null;\n            }\n\n            return [2\n            /*return*/\n            , ret];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch all parties on the ledger.\n   *\n   * @returns All parties on the ledger, in no particular order.\n   *\n   */\n\n\n  Ledger.prototype.listKnownParties = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.submit('v1/parties', undefined, 'get')];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , decode(jtv.array(partyInfoDecoder), json)];\n        }\n      });\n    });\n  };\n  /**\n   * Allocate a new party.\n   *\n   * @param partyOpt Parameters for party allocation.\n   *\n   * @returns PartyInfo for the newly created party.\n   *\n   */\n\n\n  Ledger.prototype.allocateParty = function (partyOpt) {\n    return __awaiter(this, void 0, void 0, function () {\n      var json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.submit('v1/parties/allocate', partyOpt)];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , decode(partyInfoDecoder, json)];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a list of all package IDs from the ledger.\n   *\n   * @returns List of package IDs.\n   *\n   */\n\n\n  Ledger.prototype.listPackages = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.submit('v1/packages', undefined, 'get')];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , decode(jtv.array(jtv.string()), json)];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a binary package.\n   *\n   * @returns The content of the package as a raw ArrayBuffer.\n   *\n   */\n\n\n  Ledger.prototype.getPackage = function (id) {\n    return __awaiter(this, void 0, void 0, function () {\n      var httpResponse;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , cross_fetch_1.default(this.httpBaseUrl + 'v1/packages/' + id, {\n              headers: this.auth(),\n              method: 'get'\n            })];\n\n          case 1:\n            httpResponse = _a.sent();\n            return [4\n            /*yield*/\n            , this.throwOnError(httpResponse)];\n\n          case 2:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , httpResponse.arrayBuffer()];\n\n          case 3:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n  /**\n   * Upload a binary archive. Note that this requires admin privileges.\n   *\n   * @returns No return value on success; throws on error.\n   *\n   */\n\n\n  Ledger.prototype.uploadDarFile = function (abuf) {\n    return __awaiter(this, void 0, void 0, function () {\n      var httpResponse;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , cross_fetch_1.default(this.httpBaseUrl + 'v1/packages', {\n              body: abuf,\n              headers: __assign(__assign({}, this.auth()), {\n                'Content-type': 'application/octet-stream'\n              }),\n              method: 'post'\n            })];\n\n          case 1:\n            httpResponse = _a.sent();\n            return [4\n            /*yield*/\n            , this.throwOnError(httpResponse)];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return Ledger;\n}();\n\nexports.default = Ledger;","map":{"version":3,"sources":["../../../../../../language-support/ts/daml-ledger/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assert = void 0;\n// Copyright (c) 2021 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar types_1 = require(\"@daml/types\");\nvar jtv = __importStar(require(\"@mojotech/json-type-validation\"));\nvar cross_fetch_1 = __importDefault(require(\"cross-fetch\"));\nvar events_1 = require(\"events\");\nvar isomorphic_ws_1 = __importDefault(require(\"isomorphic-ws\"));\nvar lodash_1 = __importDefault(require(\"lodash\"));\nvar partyInfoDecoder = jtv.object({\n    identifier: jtv.string(),\n    displayName: jtv.optional(jtv.string()),\n    isLocal: jtv.boolean(),\n});\nvar decode = function (decoder, data) {\n    return jtv.Result.withException(decoder.run(data));\n};\n/**\n * Decoder for a [[CreateEvent]].\n */\nvar decodeCreateEvent = function (template) { return jtv.object({\n    templateId: jtv.constant(template.templateId),\n    contractId: types_1.ContractId(template).decoder,\n    signatories: types_1.List(types_1.Party).decoder,\n    observers: types_1.List(types_1.Party).decoder,\n    agreementText: types_1.Text.decoder,\n    key: template.keyDecoder,\n    payload: template.decoder,\n}); };\n/**\n * Decoder for a [[CreateEvent]] of unknown contract template.\n */\nvar decodeCreateEventUnknown = jtv.valueAt(['templateId'], jtv.string()).andThen(function (templateId) {\n    return decodeCreateEvent(types_1.lookupTemplate(templateId));\n});\n/**\n * Decoder for an [[ArchiveEvent]].\n */\nvar decodeArchiveEvent = function (template) { return jtv.object({\n    templateId: jtv.constant(template.templateId),\n    contractId: types_1.ContractId(template).decoder,\n}); };\n/**\n * Decoder for an [[ArchiveEvent]] of unknown contract template.\n */\nvar decodeArchiveEventUnknown = jtv.valueAt(['templateId'], jtv.string()).andThen(function (templateId) {\n    return decodeArchiveEvent(types_1.lookupTemplate(templateId));\n});\n/**\n * Decoder for an [[Event]].\n */\nvar decodeEvent = function (template) { return jtv.oneOf(jtv.object({ created: decodeCreateEvent(template) }), jtv.object({ archived: decodeArchiveEvent(template) })); };\n/**\n * Decoder for an [[Event]] with unknown contract template.\n */\nvar decodeEventUnknown = jtv.oneOf(jtv.object({ created: decodeCreateEventUnknown }), jtv.object({ archived: decodeArchiveEventUnknown }));\n/**\n * @internal\n */\nfunction decodeArchiveResponse(template, archiveMethod, archiveCommand) {\n    return __awaiter(this, void 0, void 0, function () {\n        var _a, _b, events;\n        return __generator(this, function (_c) {\n            switch (_c.label) {\n                case 0: return [4 /*yield*/, archiveCommand()];\n                case 1:\n                    _a = _c.sent(), _b = _a[0], events = _a[1];\n                    if (events.length === 1 && 'archived' in events[0] && events[0].archived.templateId === template.templateId) {\n                        return [2 /*return*/, events[0].archived];\n                    }\n                    else {\n                        throw Error(\"Ledger.\" + archiveMethod + \" is expected to cause one archive event for template \" + template.templateId + \"       but caused \" + JSON.stringify(events) + \".\");\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\n/**\n * @internal\n */\nfunction isRecordWith(field, x) {\n    return typeof x === 'object' && x !== null && field in x;\n}\n/** @internal\n * exported for testing only\n */\nfunction assert(b, m) {\n    if (!b) {\n        throw m;\n    }\n}\nexports.assert = assert;\n// TODO(MH): Support comparison queries.\n/** @internal\n *\n * Official documentation (docs/source/json-api/search-query-language.rst)\n * currently explicitly forbids the use of lists, textmaps and genmaps in\n * queries. As long as that restriction stays, there is no need for any kind of\n * encoding here.\n */\nfunction encodeQuery(template, query) {\n    // I could not get the \"unused\" warning silenced, but this seems to count as \"used\"\n    [template];\n    return query;\n}\n/**\n * @internal\n */\nvar decodeLedgerResponse = jtv.object({\n    status: jtv.number(),\n    result: jtv.unknownJson(),\n    warnings: jtv.optional(jtv.unknownJson()),\n});\n/**\n * @internal\n */\nvar decodeLedgerError = jtv.object({\n    status: jtv.number(),\n    errors: jtv.array(jtv.string()),\n    warnings: jtv.optional(jtv.unknownJson()),\n});\n/**\n * An object of type `Ledger` represents a handle to a Daml ledger.\n */\nvar Ledger = /** @class */ (function () {\n    /**\n     * Construct a new `Ledger` object. See [[LedgerOptions]] for the constructor arguments.\n     */\n    function Ledger(_a) {\n        var token = _a.token, httpBaseUrl = _a.httpBaseUrl, wsBaseUrl = _a.wsBaseUrl, _b = _a.reconnectThreshold, reconnectThreshold = _b === void 0 ? 30000 : _b;\n        if (!httpBaseUrl) {\n            httpBaseUrl = window.location.protocol + \"//\" + window.location.host + \"/\";\n        }\n        if (!(httpBaseUrl.startsWith('http://') || httpBaseUrl.startsWith('https://'))) {\n            throw Error(\"Ledger: httpBaseUrl must start with 'http://' or 'https://'. (\" + httpBaseUrl + \")\");\n        }\n        if (!httpBaseUrl.endsWith('/')) {\n            throw Error(\"Ledger: httpBaseUrl must end with '/'. (\" + httpBaseUrl + \")\");\n        }\n        if (!wsBaseUrl) {\n            wsBaseUrl = 'ws' + httpBaseUrl.slice(4);\n        }\n        if (!(wsBaseUrl.startsWith('ws://') || wsBaseUrl.startsWith('wss://'))) {\n            throw Error(\"Ledger: wsBaseUrl must start with 'ws://' or 'wss://'. (\" + wsBaseUrl + \")\");\n        }\n        if (!wsBaseUrl.endsWith('/')) {\n            throw Error(\"Ledger: wsBaseUrl must end with '/'. (\" + wsBaseUrl + \")\");\n        }\n        this.token = token;\n        this.httpBaseUrl = httpBaseUrl;\n        this.wsBaseUrl = wsBaseUrl;\n        this.reconnectThreshold = reconnectThreshold;\n    }\n    /**\n     * @internal\n     */\n    Ledger.prototype.auth = function () {\n        return { 'Authorization': 'Bearer ' + this.token };\n    };\n    /**\n     * @internal\n     */\n    Ledger.prototype.throwOnError = function (r) {\n        return __awaiter(this, void 0, void 0, function () {\n            var json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!!r.ok) return [3 /*break*/, 2];\n                        return [4 /*yield*/, r.json()];\n                    case 1:\n                        json = _a.sent();\n                        console.log(json);\n                        throw decode(decodeLedgerError, json);\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * @internal\n     *\n     * Internal function to submit a command to the JSON API.\n     */\n    Ledger.prototype.submit = function (endpoint, payload, method) {\n        if (method === void 0) { method = 'post'; }\n        return __awaiter(this, void 0, void 0, function () {\n            var httpResponse, json, ledgerResponse;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, cross_fetch_1.default(this.httpBaseUrl + endpoint, {\n                            body: JSON.stringify(payload),\n                            headers: __assign(__assign({}, this.auth()), { 'Content-type': 'application/json' }),\n                            method: method,\n                        })];\n                    case 1:\n                        httpResponse = _a.sent();\n                        return [4 /*yield*/, this.throwOnError(httpResponse)];\n                    case 2:\n                        _a.sent();\n                        return [4 /*yield*/, httpResponse.json()];\n                    case 3:\n                        json = _a.sent();\n                        ledgerResponse = jtv.Result.withException(decodeLedgerResponse.run(json));\n                        if (ledgerResponse.warnings) {\n                            console.warn(ledgerResponse.warnings);\n                        }\n                        return [2 /*return*/, ledgerResponse.result];\n                }\n            });\n        });\n    };\n    /**\n     * Retrieve contracts for a given template.\n     *\n     * When no `query` argument is given, all contracts visible to the submitting party are returned.\n     * When a `query` argument is given, only those contracts matching the query are returned. See\n     * https://docs.daml.com/json-api/search-query-language.html for a description of the query\n     * language.\n     *\n     * @param template The contract template of the contracts to be matched against.\n     * @param query The contract query for the contracts to be matched against.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     *\n     */\n    Ledger.prototype.query = function (template, query) {\n        return __awaiter(this, void 0, void 0, function () {\n            var payload, json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        payload = { templateIds: [template.templateId], query: encodeQuery(template, query) };\n                        return [4 /*yield*/, this.submit('v1/query', payload)];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, jtv.Result.withException(jtv.array(decodeCreateEvent(template)).run(json))];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch a contract identified by its contract ID.\n     *\n     * @param template The template of the contract to be fetched.\n     * @param contractId The contract id of the contract to be fetched.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     *\n     */\n    Ledger.prototype.fetch = function (template, contractId) {\n        return __awaiter(this, void 0, void 0, function () {\n            var payload, json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        payload = {\n                            templateId: template.templateId,\n                            contractId: types_1.ContractId(template).encode(contractId),\n                        };\n                        return [4 /*yield*/, this.submit('v1/fetch', payload)];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, jtv.Result.withException(jtv.oneOf(jtv.constant(null), decodeCreateEvent(template)).run(json))];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch a contract identified by its contract key.\n     *\n     * Same as [[fetch]], but the contract to be fetched is identified by its contract key instead of\n     * its contract id.\n     *\n     * @param template The template of the contract to be fetched.\n     * @param key The contract key of the contract to be fetched.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     */\n    Ledger.prototype.fetchByKey = function (template, key) {\n        return __awaiter(this, void 0, void 0, function () {\n            var payload, json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (key === undefined) {\n                            throw Error(\"Cannot lookup by key on template \" + template.templateId + \" because it does not define a key.\");\n                        }\n                        payload = {\n                            templateId: template.templateId,\n                            key: template.keyEncode(key),\n                        };\n                        return [4 /*yield*/, this.submit('v1/fetch', payload)];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, jtv.Result.withException(jtv.oneOf(jtv.constant(null), decodeCreateEvent(template)).run(json))];\n                }\n            });\n        });\n    };\n    /**\n     * Create a contract for a given template.\n     *\n     * @param template The template of the contract to be created.\n     * @param payload The template arguments for the contract to be created.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     *\n     */\n    Ledger.prototype.create = function (template, payload) {\n        return __awaiter(this, void 0, void 0, function () {\n            var command, json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        command = {\n                            templateId: template.templateId,\n                            payload: template.encode(payload),\n                        };\n                        return [4 /*yield*/, this.submit('v1/create', command)];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, jtv.Result.withException(decodeCreateEvent(template).run(json))];\n                }\n            });\n        });\n    };\n    /**\n     * Exercise a choice on a contract identified by its contract ID.\n     *\n     * @param choice The choice to exercise.\n     * @param contractId The contract id of the contract to exercise.\n     * @param argument The choice arguments.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam C The type of the contract choice.\n     * @typeparam R The return type of the choice.\n     *\n     * @returns The return value of the choice together with a list of\n     * [[event]]'s that were created as a result of exercising the choice.\n     */\n    Ledger.prototype.exercise = function (choice, contractId, argument) {\n        return __awaiter(this, void 0, void 0, function () {\n            var payload, json, responseDecoder, _a, exerciseResult, events;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        payload = {\n                            templateId: choice.template().templateId,\n                            contractId: types_1.ContractId(choice.template()).encode(contractId),\n                            choice: choice.choiceName,\n                            argument: choice.argumentEncode(argument),\n                        };\n                        return [4 /*yield*/, this.submit('v1/exercise', payload)];\n                    case 1:\n                        json = _b.sent();\n                        responseDecoder = jtv.object({\n                            exerciseResult: choice.resultDecoder,\n                            events: jtv.array(decodeEventUnknown),\n                        });\n                        _a = jtv.Result.withException(responseDecoder.run(json)), exerciseResult = _a.exerciseResult, events = _a.events;\n                        return [2 /*return*/, [exerciseResult, events]];\n                }\n            });\n        });\n    };\n    /**\n     * Exercse a choice on a newly-created contract, in a single transaction.\n     *\n     * @param choice The choice to exercise.\n     * @param init The template arguments for the newly-created contract.\n     * @param argument The choice arguments.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam C The type of the contract choice.\n     * @typeparam R The return type of the choice.\n     *\n     * @returns The return value of the choice together with a list of\n     * [[event]]'s that includes the creation event for the created contract as\n     * well as all the events that were created as a result of exercising the\n     * choice, including the archive event for the created contract if the choice\n     * is consuming (or otherwise archives it as part of its execution).\n     *\n     */\n    Ledger.prototype.createAndExercise = function (choice, payload, argument) {\n        return __awaiter(this, void 0, void 0, function () {\n            var command, json, responseDecoder, _a, exerciseResult, events;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        command = {\n                            templateId: choice.template().templateId,\n                            payload: choice.template().encode(payload),\n                            choice: choice.choiceName,\n                            argument: choice.argumentEncode(argument),\n                        };\n                        return [4 /*yield*/, this.submit('v1/create-and-exercise', command)];\n                    case 1:\n                        json = _b.sent();\n                        responseDecoder = jtv.object({\n                            exerciseResult: choice.resultDecoder,\n                            events: jtv.array(decodeEventUnknown),\n                        });\n                        _a = jtv.Result.withException(responseDecoder.run(json)), exerciseResult = _a.exerciseResult, events = _a.events;\n                        return [2 /*return*/, [exerciseResult, events]];\n                }\n            });\n        });\n    };\n    /**\n     * Exercise a choice on a contract identified by its contract key.\n     *\n     * Same as [[exercise]], but the contract is identified by its contract key instead of its\n     * contract id.\n     *\n     * @param choice The choice to exercise.\n     * @param contractId The contract id of the contract to exercise.\n     * @param argument The choice arguments.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam C The type of the contract choice.\n     * @typeparam R The return type of the choice.\n     * @typeparam K The type of the contract key.\n     *\n     * @returns The return value of the choice together with a list of [[event]]'s that where created\n     * as a result of exercising the choice.\n     */\n    Ledger.prototype.exerciseByKey = function (choice, key, argument) {\n        return __awaiter(this, void 0, void 0, function () {\n            var payload, json, responseDecoder, _a, exerciseResult, events;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (key === undefined) {\n                            throw Error(\"Cannot exercise by key on template \" + choice.template().templateId + \" because it does not define a key.\");\n                        }\n                        payload = {\n                            templateId: choice.template().templateId,\n                            key: choice.template().keyEncode(key),\n                            choice: choice.choiceName,\n                            argument: choice.argumentEncode(argument),\n                        };\n                        return [4 /*yield*/, this.submit('v1/exercise', payload)];\n                    case 1:\n                        json = _b.sent();\n                        responseDecoder = jtv.object({\n                            exerciseResult: choice.resultDecoder,\n                            events: jtv.array(decodeEventUnknown),\n                        });\n                        _a = jtv.Result.withException(responseDecoder.run(json)), exerciseResult = _a.exerciseResult, events = _a.events;\n                        return [2 /*return*/, [exerciseResult, events]];\n                }\n            });\n        });\n    };\n    /**\n     * Archive a contract identified by its contract ID.\n     *\n     * @param template The template of the contract to archive.\n     * @param contractId The contract id of the contract to archive.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     *\n     */\n    Ledger.prototype.archive = function (template, contractId) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                return [2 /*return*/, decodeArchiveResponse(template, 'archive', function () { return _this.exercise(template.Archive, contractId, {}); })];\n            });\n        });\n    };\n    /**\n     * Archive a contract identified by its contract key.\n     * Same as [[archive]], but the contract to be archived is identified by its contract key.\n     *\n     * @param template The template of the contract to be archived.\n     * @param key The contract key of the contract to be archived.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     *\n     */\n    Ledger.prototype.archiveByKey = function (template, key) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                return [2 /*return*/, decodeArchiveResponse(template, 'archiveByKey', function () { return _this.exerciseByKey(template.Archive, key, {}); })];\n            });\n        });\n    };\n    /**\n     * @internal\n     *\n     * Internal command to submit a request to a streaming endpoint of the\n     * JSON API. Returns a stream consisting of accumulated state together with\n     * the events that produced the latest state change. The `change` function\n     * must be an operation of the monoid `Event<T, K, I>[]` on the set `State`,\n     * i.e., for all `s: State` and `x, y: Event<T, K, I>[]` we\n     * must have the structural equalities\n     * ```\n     * change(s, []) == s\n     * change(s, x.concat(y)) == change(change(s, x), y)\n     * ```\n     * Also, `change` must never change its arguments.\n     */\n    Ledger.prototype.streamSubmit = function (callerName, template, endpoint, request, reconnectRequest, init, change) {\n        var _this = this;\n        var protocols = ['jwt.token.' + this.token, 'daml.ws.auth'];\n        var ws = new isomorphic_ws_1.default(this.wsBaseUrl + endpoint, protocols);\n        var isLiveSince = undefined;\n        var lastOffset = undefined;\n        var state = init;\n        var isReconnecting = false;\n        var streamClosed = false;\n        var emitter = new events_1.EventEmitter();\n        var onWsOpen = function () {\n            if (isReconnecting) {\n                // the JSON API server can't handle null offsets, even though it sends them out under\n                // special conditions when there are no transactions yet. Not sending the `offset` message\n                // will start the stream from the very beginning of the transaction log.\n                if (lastOffset !== null)\n                    ws.send(JSON.stringify({ 'offset': lastOffset }));\n                ws.send(JSON.stringify(reconnectRequest()));\n            }\n            else {\n                ws.send(JSON.stringify(request));\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var onWsMessage = function (event) {\n            var json = JSON.parse(event.data.toString());\n            if (isRecordWith('events', json)) {\n                var events = jtv.Result.withException(jtv.array(decodeEvent(template)).run(json.events));\n                if (events.length > 0) {\n                    state = change(state, events);\n                    emitter.emit('change', state, events);\n                }\n                if (isRecordWith('offset', json)) {\n                    lastOffset = jtv.Result.withException(jtv.oneOf(jtv.constant(null), jtv.string()).run(json.offset));\n                    if (isLiveSince === undefined) {\n                        isLiveSince = Date.now();\n                        emitter.emit('live', state);\n                    }\n                }\n            }\n            else if (isRecordWith('warnings', json)) {\n                console.warn(\"Ledger.\" + callerName + \" warnings\", json);\n            }\n            else if (isRecordWith('errors', json)) {\n                console.error(\"Ledger.\" + callerName + \" errors\", json);\n            }\n            else {\n                console.error(\"Ledger.\" + callerName + \" unknown message\", json);\n            }\n        };\n        var closeStream = function (status) {\n            streamClosed = true;\n            emitter.emit('close', status);\n            emitter.removeAllListeners();\n        };\n        var onWsClose = function () {\n            if (streamClosed === false) {\n                var now = new Date().getTime();\n                // we want to try and keep the stream open, so we try to reconnect\n                // the underlying ws\n                if (lastOffset !== undefined && isLiveSince !== undefined && now - isLiveSince >= _this.reconnectThreshold) {\n                    isLiveSince = undefined;\n                    isReconnecting = true;\n                    ws = new isomorphic_ws_1.default(_this.wsBaseUrl + endpoint, protocols);\n                    ws.addEventListener('open', onWsOpen);\n                    ws.addEventListener('message', onWsMessage);\n                    ws.addEventListener('close', onWsClose);\n                }\n                else {\n                    // ws has closed too quickly / never managed to connect: we give up\n                    closeStream({ code: 4001, reason: 'ws connection failed' });\n                }\n            } // no else: if the stream is closed we don't need to keep a ws\n        };\n        ws.addEventListener('open', onWsOpen);\n        ws.addEventListener('message', onWsMessage);\n        // NOTE(MH): We ignore the 'error' event since it is always followed by a\n        // 'close' event, which we need to handle anyway.\n        ws.addEventListener('close', onWsClose);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var on = function (type, listener) {\n            if (streamClosed === false) {\n                void emitter.on(type, listener);\n            }\n            else {\n                console.error(\"Trying to add a listener to a closed stream.\");\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var off = function (type, listener) {\n            if (streamClosed === false) {\n                void emitter.off(type, listener);\n            }\n            else {\n                console.error(\"Trying to remove a listener from a closed stream.\");\n            }\n        };\n        var close = function () {\n            // Note: ws.close will trigger the onClose handlers of the WebSocket\n            // (here onWsClose), but they execute as a separate event after the\n            // current event in the JS event loop, i.e. in particular after the call\n            // to closeStream and thus, in this case, the onWsClose handler will see\n            // streamClosed as true.\n            ws.close();\n            closeStream({ code: 4000, reason: \"called .close()\" });\n        };\n        return { on: on, off: off, close: close };\n    };\n    /**\n     * Retrieve a consolidated stream of events for a given template and query.\n     *\n     * The accumulated state is the current set of active contracts matching the query. When no\n     * `query` argument is given, all events visible to the submitting party are returned. When a\n     * `query` argument is given, only those create events matching the query are returned. See\n     * https://docs.daml.com/json-api/search-query-language.html for a description of the query\n     * language.\n     *\n     * @deprecated Prefer `streamQueries`.\n     *\n     * @param template The contract template to match contracts against.\n     * @param query The query to match contracts agains.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     *\n     */\n    Ledger.prototype.streamQuery = function (template, query) {\n        if (query === undefined) {\n            return this.streamQueryCommon(template, [], \"streamQuery\");\n        }\n        else {\n            return this.streamQueryCommon(template, [query], \"streamQuery\");\n        }\n    };\n    /**\n     * @internal\n     *\n     */\n    Ledger.prototype.streamQueryCommon = function (template, queries, name) {\n        var request = queries.length == 0 ?\n            [{ templateIds: [template.templateId] }]\n            : queries.map(function (q) { return ({ templateIds: [template.templateId], query: encodeQuery(template, q) }); });\n        var reconnectRequest = function () { return request; };\n        var change = function (contracts, events) {\n            var archiveEvents = new Set();\n            var createEvents = [];\n            for (var _i = 0, events_2 = events; _i < events_2.length; _i++) {\n                var event_1 = events_2[_i];\n                if ('created' in event_1) {\n                    createEvents.push(event_1.created);\n                }\n                else { // i.e. 'archived' in event\n                    archiveEvents.add(event_1.archived.contractId);\n                }\n            }\n            return contracts\n                .concat(createEvents)\n                .filter(function (contract) { return !archiveEvents.has(contract.contractId); });\n        };\n        return this.streamSubmit(name, template, 'v1/stream/query', request, reconnectRequest, [], change);\n    };\n    /**\n     * Retrieve a consolidated stream of events for a given template and queries.\n     *\n     * If the given list is empty, the accumulated state is the set of all active\n     * contracts for the given template. Otherwise, the accumulated state is the\n     * set of all contracts that match at least one of the given queries.\n     *\n     * See https://docs.daml.com/json-api/search-query-language.html for a\n     * description of the query language.\n     *\n     * @param template The contract template to match contracts against.\n     * @param query A query to match contracts against.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     */\n    Ledger.prototype.streamQueries = function (template, queries) {\n        return this.streamQueryCommon(template, queries, \"streamQueries\");\n    };\n    /**\n     * Retrieve a consolidated stream of events for a given template and contract key.\n     *\n     * The accumulated state is either the current active contract for the given\n     * key, or null if there is no active contract for the given key.\n     *\n     * @deprecated Prefer `streamFetchByKeys`.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     *\n     */\n    Ledger.prototype.streamFetchByKey = function (template, key) {\n        // Note: this implementation is deliberately not unified with that of\n        // `streamFetchByKeys`, because doing so would add the requirement that the\n        // given key be in output format, whereas existing implementation supports\n        // input format.\n        var lastContractId = null;\n        var request = [{ templateId: template.templateId, key: template.keyEncode(key) }];\n        var reconnectRequest = function () { return [__assign(__assign({}, request[0]), { 'contractIdAtOffset': lastContractId && types_1.ContractId(template).encode(lastContractId) })]; };\n        var change = function (contract, events) {\n            for (var _i = 0, events_3 = events; _i < events_3.length; _i++) {\n                var event_2 = events_3[_i];\n                if ('created' in event_2) {\n                    contract = event_2.created;\n                }\n                else { // i.e. 'archived' event\n                    if (contract && contract.contractId === event_2.archived.contractId) {\n                        contract = null;\n                    }\n                }\n            }\n            lastContractId = contract ? contract.contractId : null;\n            return contract;\n        };\n        return this.streamSubmit(\"streamFetchByKey\", template, 'v1/stream/fetch', request, reconnectRequest, null, change);\n    };\n    /**\n     * @internal\n     *\n     * Returns the same API as [[streamSubmit]] but does not, in fact, establish\n     * any socket connection. Instead, this is a stream that always has the given\n     * value as its accumulated state.\n     */\n    Ledger.prototype.constantStream = function (value) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        function on(type, listener) {\n            if (type === 'live') {\n                listener(value);\n            }\n            if (type === 'change') {\n                listener(value, []);\n            }\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function\n        function off(_t, _l) { }\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        return { on: on, off: off, close: function () { } };\n    };\n    /**\n     * Retrieve a consolidated stream of events for a list of keys and a single\n     * template.\n     *\n     * The accumulated state is an array of the same length as the given list of\n     * keys, with positional correspondence. Each element in the array represents\n     * the current contract for the given key, or is explicitly null if there is\n     * currently no active contract matching that key.\n     *\n     * Note: the given `key` objects will be compared for (deep) equality with\n     * the values returned by the API. As such, they have to be given in the\n     * \"output\" format of the API, including the values of\n     * `encodeDecimalAsString` and `encodeInt64AsString`. See [the JSON API docs\n     * for details](https://docs.daml.com/json-api/lf-value-specification.html).\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     */\n    Ledger.prototype.streamFetchByKeys = function (template, keys) {\n        // We support zero-length key so clients can more easily manage a dynamic\n        // list, without having to special-case 0-length on their side.\n        if (keys.length == 0) {\n            return this.constantStream([]);\n        }\n        var lastContractIds = Array(keys.length).fill(null);\n        var keysCopy = lodash_1.default.cloneDeep(keys);\n        var initState = Array(keys.length).fill(null);\n        var request = keys.map(function (k) { return ({ templateId: template.templateId, key: template.keyEncode(k) }); });\n        var reconnectRequest = function () { return request.map(function (r, idx) {\n            var lastId = lastContractIds[idx];\n            return __assign(__assign({}, r), { 'contractIdAtOffset': lastId && types_1.ContractId(template).encode(lastId) });\n        }); };\n        var change = function (state, events) {\n            var newState = Array.from(state);\n            var _loop_1 = function (event_3) {\n                if ('created' in event_3) {\n                    var k_1 = event_3.created.key;\n                    keysCopy.forEach(function (requestKey, idx) {\n                        if (lodash_1.default.isEqual(requestKey, k_1)) {\n                            newState[idx] = event_3.created;\n                        }\n                    });\n                }\n                else { // i.e. 'archived' in event\n                    var id_1 = event_3.archived.contractId;\n                    newState.forEach(function (contract, idx) {\n                        if (contract && contract.contractId === id_1) {\n                            newState[idx] = null;\n                        }\n                    });\n                }\n            };\n            for (var _i = 0, events_4 = events; _i < events_4.length; _i++) {\n                var event_3 = events_4[_i];\n                _loop_1(event_3);\n            }\n            newState.forEach(function (c, idx) {\n                lastContractIds[idx] = c ? c.contractId : null;\n            });\n            return newState;\n        };\n        return this.streamSubmit(\"streamFetchByKeys\", template, 'v1/stream/fetch', request, reconnectRequest, initState, change);\n    };\n    /**\n     * Fetch parties by identifier.\n     *\n     * @param parties An array of Party identifiers.\n     *\n     * @returns An array of the same length, where each element corresponds to\n     * the same-index element of the given parties, ans is either a PartyInfo\n     * object if the party exists or null if it does not.\n     *\n     */\n    Ledger.prototype.getParties = function (parties) {\n        return __awaiter(this, void 0, void 0, function () {\n            var json, resp, mapping, _i, resp_1, p, ret, idx;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (parties.length === 0) {\n                            return [2 /*return*/, []];\n                        }\n                        return [4 /*yield*/, this.submit('v1/parties', parties)];\n                    case 1:\n                        json = _a.sent();\n                        resp = decode(jtv.array(partyInfoDecoder), json);\n                        mapping = {};\n                        for (_i = 0, resp_1 = resp; _i < resp_1.length; _i++) {\n                            p = resp_1[_i];\n                            mapping[p.identifier] = p;\n                        }\n                        ret = Array(parties.length).fill(null);\n                        for (idx = 0; idx < parties.length; idx++) {\n                            ret[idx] = mapping[parties[idx]] || null;\n                        }\n                        return [2 /*return*/, ret];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch all parties on the ledger.\n     *\n     * @returns All parties on the ledger, in no particular order.\n     *\n     */\n    Ledger.prototype.listKnownParties = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.submit('v1/parties', undefined, 'get')];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, decode(jtv.array(partyInfoDecoder), json)];\n                }\n            });\n        });\n    };\n    /**\n     * Allocate a new party.\n     *\n     * @param partyOpt Parameters for party allocation.\n     *\n     * @returns PartyInfo for the newly created party.\n     *\n     */\n    Ledger.prototype.allocateParty = function (partyOpt) {\n        return __awaiter(this, void 0, void 0, function () {\n            var json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.submit('v1/parties/allocate', partyOpt)];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, decode(partyInfoDecoder, json)];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch a list of all package IDs from the ledger.\n     *\n     * @returns List of package IDs.\n     *\n     */\n    Ledger.prototype.listPackages = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.submit('v1/packages', undefined, 'get')];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, decode(jtv.array(jtv.string()), json)];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch a binary package.\n     *\n     * @returns The content of the package as a raw ArrayBuffer.\n     *\n     */\n    Ledger.prototype.getPackage = function (id) {\n        return __awaiter(this, void 0, void 0, function () {\n            var httpResponse;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, cross_fetch_1.default(this.httpBaseUrl + 'v1/packages/' + id, {\n                            headers: this.auth(),\n                            method: 'get',\n                        })];\n                    case 1:\n                        httpResponse = _a.sent();\n                        return [4 /*yield*/, this.throwOnError(httpResponse)];\n                    case 2:\n                        _a.sent();\n                        return [4 /*yield*/, httpResponse.arrayBuffer()];\n                    case 3: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * Upload a binary archive. Note that this requires admin privileges.\n     *\n     * @returns No return value on success; throws on error.\n     *\n     */\n    Ledger.prototype.uploadDarFile = function (abuf) {\n        return __awaiter(this, void 0, void 0, function () {\n            var httpResponse;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, cross_fetch_1.default(this.httpBaseUrl + 'v1/packages', {\n                            body: abuf,\n                            headers: __assign(__assign({}, this.auth()), { 'Content-type': 'application/octet-stream' }),\n                            method: 'post',\n                        })];\n                    case 1:\n                        httpResponse = _a.sent();\n                        return [4 /*yield*/, this.throwOnError(httpResponse)];\n                    case 2:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return Ledger;\n}());\nexports.default = Ledger;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}